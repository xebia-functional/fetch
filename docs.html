<!DOCTYPE html><html><head><title>Fetch</title><meta charset="utf-8" /><meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" /><meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="author" content="47 Degrees Open Source" /><meta name="description" content="Simple &amp; Efficient data fetching" /><meta name="og:image" content="/fetch/img/poster.png" /><meta name="image" property="og:image" content="/fetch/img/poster.png" /><meta name="og:title" content="Fetch" /><meta name="title" property="og:title" content="Fetch" /><meta name="og:site_name" content="Fetch" /><meta name="og:url" content="https://github.com/47degrees/fetch" /><meta name="og:type" content="website" /><meta name="og:description" content="Simple &amp; Efficient data fetching" /><link rel="icon" type="image/png" href="/fetch/img/favicon.png" /><meta name="twitter:title" content="Fetch" /><meta name="twitter:image" content="/fetch/img/poster.png" /><meta name="twitter:description" content="Simple &amp; Efficient data fetching" /><meta name="twitter:card" content="summary_large_image" /><link rel="icon" type="image/png" sizes="16x16" href="/fetch/img/favicon16x16.png" /><link rel="icon" type="image/png" sizes="24x24" href="/fetch/img/favicon24x24.png" /><link rel="icon" type="image/png" sizes="32x32" href="/fetch/img/favicon32x32.png" /><link rel="icon" type="image/png" sizes="48x48" href="/fetch/img/favicon48x48.png" /><link rel="icon" type="image/png" sizes="57x57" href="/fetch/img/favicon57x57.png" /><link rel="icon" type="image/png" sizes="60x60" href="/fetch/img/favicon60x60.png" /><link rel="icon" type="image/png" sizes="64x64" href="/fetch/img/favicon64x64.png" /><link rel="icon" type="image/png" sizes="70x70" href="/fetch/img/favicon70x70.png" /><link rel="icon" type="image/png" sizes="72x72" href="/fetch/img/favicon72x72.png" /><link rel="icon" type="image/png" sizes="76x76" href="/fetch/img/favicon76x76.png" /><link rel="icon" type="image/png" sizes="96x96" href="/fetch/img/favicon96x96.png" /><link rel="icon" type="image/png" sizes="114x114" href="/fetch/img/favicon114x114.png" /><link rel="icon" type="image/png" sizes="120x120" href="/fetch/img/favicon120x120.png" /><link rel="icon" type="image/png" sizes="128x128" href="/fetch/img/favicon128x128.png" /><link rel="icon" type="image/png" sizes="144x144" href="/fetch/img/favicon144x144.png" /><link rel="icon" type="image/png" sizes="150x150" href="/fetch/img/favicon150x150.png" /><link rel="icon" type="image/png" sizes="152x152" href="/fetch/img/favicon152x152.png" /><link rel="icon" type="image/png" sizes="196x196" href="/fetch/img/favicon196x196.png" /><link rel="icon" type="image/png" sizes="310x310" href="/fetch/img/favicon310x310.png" /><link rel="icon" type="image/png" sizes="310x150" href="/fetch/img/favicon310x150.png" /><link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css" /><link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css" /><link rel="stylesheet" href="/fetch/highlight/styles/tomorrow.css" /><link rel="stylesheet" href="/fetch/css/pattern-style.css" /><link rel="stylesheet" href="/fetch/css/custom.css" /><link rel="stylesheet" href="css/custom.css" /></head><body class="docs"><div id="wrapper"><div id="sidebar-wrapper"><ul id="sidebar" class="sidebar-nav"><li class="sidebar-brand"><a href="/fetch/" class="brand"><div class="brand-wrapper"><span>Fetch</span></div></a></li><li><a href="/fetch/css/custom.css" class=" active "></a></li><li><a href="/fetch/docs.html" class=" active "></a></li><li><a href="/fetch/" class=" active "></a></li><li><a href="/fetch/css/pattern-style.css" class=" active "></a></li><li><a href="/fetch/js/search.js" class=" active "></a></li><li><a href="/fetch/css/custom.css.map" class=" active "></a></li></ul></div><div id="page-content-wrapper"><div class="nav"><div class="container-fluid"><div class="row"><div class="col-lg-12"><div class="action-menu pull-left clearfix"><a href="#menu-toggle" id="menu-toggle"><i class="fa fa-bars" aria-hidden="true"></i></a></div><ul class="pull-right"><li class="search-nav hidden-xs hidden-sm"><div id="search-dropdown"><label><i class="fa fa-search"></i>Search</label><input id="search-bar" type="text" placeholder="Enter keywords here..." onclick="displayToggleSearch(event)" /><ul id="search-dropdown-content" class="dropdown dropdown-content"></ul></div></li><li id="gh-eyes-item" class="hidden-xs to-uppercase"><a href="https://github.com/47degrees/fetch" target="_blank" rel="noopener noreferrer"><i class="fa fa-eye"></i><span>Watchers<span id="eyes" class="label label-default">--</span></span></a></li><li id="gh-stars-item" class="hidden-xs to-uppercase"><a href="https://github.com/47degrees/fetch" target="_blank" rel="noopener noreferrer"><i class="fa fa-star-o"></i><span>Stars<span id="stars" class="label label-default">--</span></span></a></li><li><a href="#" onclick="shareSiteTwitter('Fetch Simple &amp; Efficient data fetching');"><i class="fa fa-twitter"></i></a></li><li><a href="#" onclick="shareSiteFacebook('Fetch Simple &amp; Efficient data fetching');"><i class="fa fa-facebook"></i></a></li></ul></div></div></div></div><div id="content" data-github-owner="47degrees" data-github-repo="fetch"><div class="content-wrapper"><section><h1 id="introduction">Introduction</h1>

<p>Fetch is a library that allows your data fetches to be written in a concise,
composable way while executing efficiently. You don’t need to use any explicit
concurrency construct but existing idioms: applicative for concurrency and
monad for sequencing.</p>

<p>Oftentimes, our applications read and manipulate data from a variety of
different sources such as databases, web services or file systems. These data
sources are subject to latency, and we’d prefer to query them efficiently.</p>

<p>If we are just reading data, we can make a series of optimizations such as:</p>

<ul>
  <li>batching requests to the same data source</li>
  <li>requesting independent data from different sources in parallel</li>
  <li>caching previously seen results</li>
</ul>

<p>However, if we mix these optimizations with the code that fetches the data
we may end up trading clarity for performance. Furthermore, we are
mixing low-level (optimization) and high-level (business logic with the data
we read) concerns.</p>

<h1 id="installation">Installation</h1>

<p>To begin, add the following dependency to your SBT build file:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="s">"com.47deg"</span> <span class="o">%%</span> <span class="s">"fetch"</span> <span class="o">%</span> <span class="s">"3.1.2"</span>
</code></pre></div></div>

<p>Or, if using Scala.js:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="s">"com.47deg"</span> <span class="o">%%%</span> <span class="s">"fetch"</span> <span class="o">%</span> <span class="s">"3.1.2"</span>
</code></pre></div></div>

<p>Now you’ll have Fetch available in both Scala and Scala.js.</p>

<h2 id="alternatives">Alternatives</h2>

<p>There are other libraries in Scala that implement the same optimizations as Fetch does and have different design decisions. If Fetch is not suitable for you these alternatives may be a better fit:</p>

<ul>
  <li><a href="https://github.com/getclump/clump">Clump</a> it’s been around for a long time and is used in production systems at SoundCloud and LinkedIn. You can use it with Scala’s or Twitter’s Futures.</li>
</ul>

<p>If something is missing in Fetch that stops you from using it we’d appreciate if you <a href="https://github.com/47degrees/fetch/issues">open an issue in our repository</a>.</p>

<h1 id="usage">Usage</h1>

<p>In order to tell Fetch how to retrieve data, we must implement the <code class="highlighter-rouge">DataSource</code> typeclass. The <code class="highlighter-rouge">Data</code> typeclass is to tell Fetch which kind of data the source is fetching, and is used to optimize requests for the same data.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nn">cats.effect.Concurrent</span>
<span class="k">import</span> <span class="nn">cats.data.NonEmptyList</span>

<span class="k">trait</span> <span class="nc">DataSource</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]</span>, <span class="kt">Identity</span>, <span class="kt">Result</span><span class="o">]{</span>
  <span class="k">def</span> <span class="nf">data</span><span class="k">:</span> <span class="kt">Data</span><span class="o">[</span><span class="kt">Identity</span>, <span class="kt">Result</span><span class="o">]</span>

  <span class="k">def</span> <span class="nf">CF</span><span class="k">:</span> <span class="kt">Concurrent</span><span class="o">[</span><span class="kt">F</span><span class="o">]</span>

  <span class="k">def</span> <span class="nf">fetch</span><span class="o">(</span><span class="n">id</span><span class="k">:</span> <span class="kt">Identity</span><span class="o">)</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">Option</span><span class="o">[</span><span class="kt">Result</span><span class="o">]]</span>
  
  <span class="cm">/* `batch` is implemented in terms of `fetch` by default */</span>
  <span class="k">def</span> <span class="nf">batch</span><span class="o">(</span><span class="n">ids</span><span class="k">:</span> <span class="kt">NonEmptyList</span><span class="o">[</span><span class="kt">Identity</span><span class="o">])</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">Map</span><span class="o">[</span><span class="kt">Identity</span>, <span class="kt">Result</span><span class="o">]]</span>
<span class="o">}</span>
</code></pre></div></div>

<p>It takes two type parameters:</p>

<ul>
  <li><code class="highlighter-rouge">Identity</code>: the identity we want to fetch (a <code class="highlighter-rouge">UserId</code> if we were fetching users)</li>
  <li><code class="highlighter-rouge">Result</code>: the type of the data we retrieve (a <code class="highlighter-rouge">User</code> if we were fetching users)</li>
</ul>

<p>There are two methods: <code class="highlighter-rouge">fetch</code> and <code class="highlighter-rouge">batch</code>. <code class="highlighter-rouge">fetch</code> receives one identity and must return
a <code class="highlighter-rouge">Concurrent</code> containing
an optional result. Returning an <code class="highlighter-rouge">Option</code> Fetch can detect whether an identity couldn’t be fetched or no longer exists.</p>

<p>The <code class="highlighter-rouge">batch</code> method takes a non-empty list of identities and must return a <code class="highlighter-rouge">Concurrent</code> containing
a map from identities to results. Accepting a list of identities gives Fetch the ability to batch requests to
the same data source, and returning a mapping from identities to results, Fetch can detect whenever an identity
couldn’t be fetched or no longer exists.</p>

<p>The <code class="highlighter-rouge">data</code> method returns a <code class="highlighter-rouge">Data[Identity, Result]</code> instance that Fetch uses to optimize requests to the same data source, and is expected to return a singleton <code class="highlighter-rouge">object</code> that extends <code class="highlighter-rouge">Data[Identity, Result]</code>.</p>

<h2 id="writing-your-first-data-source">Writing your first data source</h2>

<p>Now that we know about the <code class="highlighter-rouge">DataSource</code> typeclass, let’s write our first data source! We’ll start by implementing a data
source for fetching users given their id. The first thing we’ll do is define the types for user ids and users.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">type</span> <span class="kt">UserId</span> <span class="o">=</span> <span class="nc">Int</span>
<span class="k">case</span> <span class="k">class</span> <span class="nc">User</span><span class="o">(</span><span class="n">id</span><span class="k">:</span> <span class="kt">UserId</span><span class="o">,</span> <span class="n">username</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span>
</code></pre></div></div>

<p>We’ll simulate unpredictable latency with this function.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nn">fetch._</span>
<span class="k">import</span> <span class="nn">cats.implicits._</span>
<span class="k">import</span> <span class="nn">cats.effect._</span>
<span class="k">import</span> <span class="nn">cats.effect.std.Console</span>
<span class="k">import</span> <span class="nn">scala.concurrent.duration._</span>

<span class="k">def</span> <span class="nf">latency</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]</span><span class="kt">:</span> <span class="kt">Console:</span> <span class="kt">Temporal</span><span class="o">](</span><span class="n">msg</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">Unit</span><span class="o">]</span> <span class="k">=</span> <span class="k">for</span> <span class="o">{</span>
  <span class="k">_</span> <span class="k">&lt;-</span> <span class="nc">Console</span><span class="o">[</span><span class="kt">F</span><span class="o">].</span><span class="py">println</span><span class="o">(</span><span class="n">s</span><span class="s">"--&gt; [${Thread.currentThread.getId}] $msg"</span><span class="o">)</span>
  <span class="k">_</span> <span class="k">&lt;-</span> <span class="nc">Temporal</span><span class="o">[</span><span class="kt">F</span><span class="o">].</span><span class="py">sleep</span><span class="o">(</span><span class="mf">100.</span><span class="n">milliseconds</span><span class="o">)</span>
  <span class="k">_</span> <span class="k">&lt;-</span> <span class="nc">Console</span><span class="o">[</span><span class="kt">F</span><span class="o">].</span><span class="py">println</span><span class="o">(</span><span class="n">s</span><span class="s">"&lt;-- [${Thread.currentThread.getId}] $msg"</span><span class="o">)</span>
<span class="o">}</span> <span class="nf">yield</span> <span class="o">()</span>
</code></pre></div></div>

<p>And now we’re ready to write our user data source; we’ll emulate a database with an in-memory map.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nn">cats.data.NonEmptyList</span>

<span class="k">val</span> <span class="nv">userDatabase</span><span class="k">:</span> <span class="kt">Map</span><span class="o">[</span><span class="kt">UserId</span>, <span class="kt">User</span><span class="o">]</span> <span class="k">=</span> <span class="nc">Map</span><span class="o">(</span>
  <span class="mi">1</span> <span class="o">-&gt;</span> <span class="nc">User</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="s">"@one"</span><span class="o">),</span>
  <span class="mi">2</span> <span class="o">-&gt;</span> <span class="nc">User</span><span class="o">(</span><span class="mi">2</span><span class="o">,</span> <span class="s">"@two"</span><span class="o">),</span>
  <span class="mi">3</span> <span class="o">-&gt;</span> <span class="nc">User</span><span class="o">(</span><span class="mi">3</span><span class="o">,</span> <span class="s">"@three"</span><span class="o">),</span>
  <span class="mi">4</span> <span class="o">-&gt;</span> <span class="nc">User</span><span class="o">(</span><span class="mi">4</span><span class="o">,</span> <span class="s">"@four"</span><span class="o">)</span>
<span class="o">)</span>

<span class="k">object</span> <span class="nc">Users</span> <span class="k">extends</span> <span class="nc">Data</span><span class="o">[</span><span class="kt">UserId</span>, <span class="kt">User</span><span class="o">]</span> <span class="o">{</span>
  <span class="k">def</span> <span class="nf">name</span> <span class="k">=</span> <span class="s">"Users"</span>

  <span class="k">def</span> <span class="nf">source</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]</span><span class="kt">:</span> <span class="kt">Console:</span> <span class="kt">Temporal</span><span class="o">]</span><span class="k">:</span> <span class="kt">DataSource</span><span class="o">[</span><span class="kt">F</span>, <span class="kt">UserId</span>, <span class="kt">User</span><span class="o">]</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">DataSource</span><span class="o">[</span><span class="kt">F</span>, <span class="kt">UserId</span>, <span class="kt">User</span><span class="o">]</span> <span class="o">{</span>
    <span class="k">override</span> <span class="k">def</span> <span class="nf">data</span> <span class="k">=</span> <span class="nc">Users</span>

    <span class="k">override</span> <span class="k">def</span> <span class="nf">CF</span> <span class="k">=</span> <span class="nc">Concurrent</span><span class="o">[</span><span class="kt">F</span><span class="o">]</span>

    <span class="k">override</span> <span class="k">def</span> <span class="nf">fetch</span><span class="o">(</span><span class="n">id</span><span class="k">:</span> <span class="kt">UserId</span><span class="o">)</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">Option</span><span class="o">[</span><span class="kt">User</span><span class="o">]]</span> <span class="k">=</span>
      <span class="n">latency</span><span class="o">[</span><span class="kt">F</span><span class="o">](</span><span class="n">s</span><span class="s">"One User $id"</span><span class="o">)</span> <span class="o">&gt;&gt;</span> <span class="nv">CF</span><span class="o">.</span><span class="py">pure</span><span class="o">(</span><span class="nv">userDatabase</span><span class="o">.</span><span class="py">get</span><span class="o">(</span><span class="n">id</span><span class="o">))</span>

    <span class="k">override</span> <span class="k">def</span> <span class="nf">batch</span><span class="o">(</span><span class="n">ids</span><span class="k">:</span> <span class="kt">NonEmptyList</span><span class="o">[</span><span class="kt">UserId</span><span class="o">])</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">Map</span><span class="o">[</span><span class="kt">UserId</span>, <span class="kt">User</span><span class="o">]]</span> <span class="k">=</span>
      <span class="n">latency</span><span class="o">[</span><span class="kt">F</span><span class="o">](</span><span class="n">s</span><span class="s">"Batch Users $ids"</span><span class="o">)</span> <span class="o">&gt;&gt;</span> <span class="nv">CF</span><span class="o">.</span><span class="py">pure</span><span class="o">(</span><span class="nv">userDatabase</span><span class="o">.</span><span class="py">view</span><span class="o">.</span><span class="py">filterKeys</span><span class="o">(</span><span class="nv">ids</span><span class="o">.</span><span class="py">toList</span><span class="o">.</span><span class="py">toSet</span><span class="o">).</span><span class="py">toMap</span><span class="o">)</span>
  <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p>Now that we have a data source we can write a function for fetching users
given a <code class="highlighter-rouge">DataSource</code>, an id and the data source as arguments to <code class="highlighter-rouge">Fetch</code>.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">getUser</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]</span><span class="kt">:</span> <span class="kt">Console:</span> <span class="kt">Temporal</span><span class="o">](</span><span class="n">id</span><span class="k">:</span> <span class="kt">UserId</span><span class="o">)</span><span class="k">:</span> <span class="kt">Fetch</span><span class="o">[</span><span class="kt">F</span>, <span class="kt">User</span><span class="o">]</span> <span class="k">=</span>
  <span class="nc">Fetch</span><span class="o">(</span><span class="n">id</span><span class="o">,</span> <span class="nv">Users</span><span class="o">.</span><span class="py">source</span><span class="o">)</span>
</code></pre></div></div>

<h3 id="optional-identities">Optional identities</h3>

<p>If you want to create a Fetch that doesn’t fail if the identity is not found, you can use <code class="highlighter-rouge">Fetch#optional</code> instead of <code class="highlighter-rouge">Fetch#apply</code>. Note that instead of a <code class="highlighter-rouge">Fetch[F, A]</code> you will get a <code class="highlighter-rouge">Fetch[F, Option[A]]</code>.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">maybeGetUser</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]</span><span class="kt">:</span> <span class="kt">Console:</span> <span class="kt">Temporal</span><span class="o">](</span><span class="n">id</span><span class="k">:</span> <span class="kt">UserId</span><span class="o">)</span><span class="k">:</span> <span class="kt">Fetch</span><span class="o">[</span><span class="kt">F</span>, <span class="kt">Option</span><span class="o">[</span><span class="kt">User</span><span class="o">]]</span> <span class="k">=</span>
  <span class="nv">Fetch</span><span class="o">.</span><span class="py">optional</span><span class="o">(</span><span class="n">id</span><span class="o">,</span> <span class="nv">Users</span><span class="o">.</span><span class="py">source</span><span class="o">)</span>
</code></pre></div></div>

<h3 id="data-sources-that-dont-support-batching">Data sources that don’t support batching</h3>

<p>If your data source doesn’t support batching, you can simply leave the <code class="highlighter-rouge">batch</code> method unimplemented. Note that it will use the <code class="highlighter-rouge">fetch</code> implementation for requesting identities in parallel.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">object</span> <span class="nc">Unbatched</span> <span class="k">extends</span> <span class="nc">Data</span><span class="o">[</span><span class="kt">Int</span>, <span class="kt">Int</span><span class="o">]</span> <span class="o">{</span>
  <span class="k">def</span> <span class="nf">name</span> <span class="k">=</span> <span class="s">"Unbatched"</span>

  <span class="k">def</span> <span class="nf">source</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]</span><span class="kt">:</span> <span class="kt">Console:</span> <span class="kt">Temporal</span><span class="o">]</span><span class="k">:</span> <span class="kt">DataSource</span><span class="o">[</span><span class="kt">F</span>, <span class="kt">Int</span>, <span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">DataSource</span><span class="o">[</span><span class="kt">F</span>, <span class="kt">Int</span>, <span class="kt">Int</span><span class="o">]{</span>
    <span class="k">override</span> <span class="k">def</span> <span class="nf">data</span> <span class="k">=</span> <span class="nc">Unbatched</span>

    <span class="k">override</span> <span class="k">def</span> <span class="nf">CF</span> <span class="k">=</span> <span class="nc">Concurrent</span><span class="o">[</span><span class="kt">F</span><span class="o">]</span>

    <span class="k">override</span> <span class="k">def</span> <span class="nf">fetch</span><span class="o">(</span><span class="n">id</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">Option</span><span class="o">[</span><span class="kt">Int</span><span class="o">]]</span> <span class="k">=</span>
      <span class="nv">CF</span><span class="o">.</span><span class="py">pure</span><span class="o">(</span><span class="nc">Option</span><span class="o">(</span><span class="n">id</span><span class="o">))</span>
  <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<h4 id="batching-individuals-requests-sequentially">Batching individuals requests sequentially</h4>

<p>The default <code class="highlighter-rouge">batch</code> implementation run requests to the data source in parallel, but you can easily override it. We can make <code class="highlighter-rouge">batch</code> sequential using <code class="highlighter-rouge">NonEmptyList.traverse</code> for fetching individual identities.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">object</span> <span class="nc">UnbatchedSeq</span> <span class="k">extends</span> <span class="nc">Data</span><span class="o">[</span><span class="kt">Int</span>, <span class="kt">Int</span><span class="o">]{</span>
  <span class="k">def</span> <span class="nf">name</span> <span class="k">=</span> <span class="s">"UnbatchedSeq"</span>

  <span class="c1">//Normally you only need F[_]: Concurrent; other examples use Console and Temporal due to the `latency` function.</span>
  <span class="k">def</span> <span class="nf">source</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]</span><span class="kt">:</span> <span class="kt">Concurrent</span><span class="o">]</span><span class="k">:</span> <span class="kt">DataSource</span><span class="o">[</span><span class="kt">F</span>, <span class="kt">Int</span>, <span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">DataSource</span><span class="o">[</span><span class="kt">F</span>, <span class="kt">Int</span>, <span class="kt">Int</span><span class="o">]{</span>
    <span class="k">override</span> <span class="k">def</span> <span class="nf">data</span> <span class="k">=</span> <span class="nc">UnbatchedSeq</span>

    <span class="k">override</span> <span class="k">def</span> <span class="nf">CF</span> <span class="k">=</span> <span class="nc">Concurrent</span><span class="o">[</span><span class="kt">F</span><span class="o">]</span>

    <span class="k">override</span> <span class="k">def</span> <span class="nf">fetch</span><span class="o">(</span><span class="n">id</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">Option</span><span class="o">[</span><span class="kt">Int</span><span class="o">]]</span> <span class="k">=</span>
      <span class="nv">CF</span><span class="o">.</span><span class="py">pure</span><span class="o">(</span><span class="nc">Option</span><span class="o">(</span><span class="n">id</span><span class="o">))</span>

    <span class="k">override</span> <span class="k">def</span> <span class="nf">batch</span><span class="o">(</span><span class="n">ids</span><span class="k">:</span> <span class="kt">NonEmptyList</span><span class="o">[</span><span class="kt">Int</span><span class="o">])</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">Map</span><span class="o">[</span><span class="kt">Int</span>, <span class="kt">Int</span><span class="o">]]</span> <span class="k">=</span>
      <span class="nv">ids</span><span class="o">.</span><span class="py">traverse</span><span class="o">(</span>
        <span class="o">(</span><span class="n">id</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="nf">fetch</span><span class="o">(</span><span class="n">id</span><span class="o">).</span><span class="py">map</span><span class="o">(</span><span class="n">v</span> <span class="k">=&gt;</span> <span class="o">(</span><span class="n">id</span><span class="o">,</span> <span class="n">v</span><span class="o">))</span>
      <span class="o">).</span><span class="py">map</span><span class="o">(</span><span class="nv">_</span><span class="o">.</span><span class="py">collect</span> <span class="o">{</span> <span class="nf">case</span> <span class="o">(</span><span class="n">i</span><span class="o">,</span> <span class="nc">Some</span><span class="o">(</span><span class="n">x</span><span class="o">))</span> <span class="k">=&gt;</span> <span class="o">(</span><span class="n">i</span><span class="o">,</span> <span class="n">x</span><span class="o">)</span> <span class="o">}.</span><span class="py">toMap</span><span class="o">)</span>
  <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<h3 id="data-sources-that-only-support-batching">Data sources that only support batching</h3>

<p>If your data source only supports querying it in batches, you can implement <code class="highlighter-rouge">fetch</code> in terms of <code class="highlighter-rouge">batch</code>.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">object</span> <span class="nc">OnlyBatched</span> <span class="k">extends</span> <span class="nc">Data</span><span class="o">[</span><span class="kt">Int</span>, <span class="kt">Int</span><span class="o">]{</span>
  <span class="k">def</span> <span class="nf">name</span> <span class="k">=</span> <span class="s">"OnlyBatched"</span>

  <span class="k">def</span> <span class="nf">source</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]</span><span class="kt">:</span> <span class="kt">Concurrent</span><span class="o">]</span><span class="k">:</span> <span class="kt">DataSource</span><span class="o">[</span><span class="kt">F</span>, <span class="kt">Int</span>, <span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">DataSource</span><span class="o">[</span><span class="kt">F</span>, <span class="kt">Int</span>, <span class="kt">Int</span><span class="o">]{</span>
    <span class="k">override</span> <span class="k">def</span> <span class="nf">data</span> <span class="k">=</span> <span class="nc">OnlyBatched</span>

    <span class="k">override</span> <span class="k">def</span> <span class="nf">CF</span> <span class="k">=</span> <span class="nc">Concurrent</span><span class="o">[</span><span class="kt">F</span><span class="o">]</span>

    <span class="k">override</span> <span class="k">def</span> <span class="nf">fetch</span><span class="o">(</span><span class="n">id</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">Option</span><span class="o">[</span><span class="kt">Int</span><span class="o">]]</span> <span class="k">=</span>
      <span class="nf">batch</span><span class="o">(</span><span class="nc">NonEmptyList</span><span class="o">(</span><span class="n">id</span><span class="o">,</span> <span class="nc">List</span><span class="o">())).</span><span class="py">map</span><span class="o">(</span><span class="nv">_</span><span class="o">.</span><span class="py">get</span><span class="o">(</span><span class="n">id</span><span class="o">))</span>

    <span class="k">override</span> <span class="k">def</span> <span class="nf">batch</span><span class="o">(</span><span class="n">ids</span><span class="k">:</span> <span class="kt">NonEmptyList</span><span class="o">[</span><span class="kt">Int</span><span class="o">])</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">Map</span><span class="o">[</span><span class="kt">Int</span>, <span class="kt">Int</span><span class="o">]]</span> <span class="k">=</span>
      <span class="nv">CF</span><span class="o">.</span><span class="py">pure</span><span class="o">(</span><span class="nv">ids</span><span class="o">.</span><span class="py">map</span><span class="o">(</span><span class="n">x</span> <span class="k">=&gt;</span> <span class="o">(</span><span class="n">x</span><span class="o">,</span> <span class="n">x</span><span class="o">)).</span><span class="py">toList</span><span class="o">.</span><span class="py">toMap</span><span class="o">)</span>
  <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<h2 id="creating-a-runtime">Creating a runtime</h2>

<p>Since we’ll use <code class="highlighter-rouge">IO</code> from the <code class="highlighter-rouge">cats-effect</code> library to execute our fetches, we’ll need an <code class="highlighter-rouge">IORuntime</code> for executing our <code class="highlighter-rouge">IO</code> instances.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nn">cats.effect.unsafe.implicits.global</span> <span class="c1">//Give</span>
</code></pre></div></div>

<p>Normally, in your applications, this is provided by <code class="highlighter-rouge">IOApp</code>, and you should not need to import this except in limited scenarios such as test environments that do not have Cats Effect integration.
For more information, and particularly on why you would usually not want to make one of these yourself, <a href="https://github.com/typelevel/cats-effect/discussions/1562#discussioncomment-254838">see this post by Daniel Spiewak</a></p>

<h2 id="creating-and-running-a-fetch">Creating and running a fetch</h2>

<p>We are now ready to create and run fetches. Note the distinction between Fetch creation and execution.
When we are creating and combining <code class="highlighter-rouge">Fetch</code> values, we are just constructing a recipe of our data
dependencies.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">fetchUser</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]</span><span class="kt">:</span> <span class="kt">Console:</span> <span class="kt">Temporal</span><span class="o">]</span><span class="k">:</span> <span class="kt">Fetch</span><span class="o">[</span><span class="kt">F</span>, <span class="kt">User</span><span class="o">]</span> <span class="k">=</span>
  <span class="nf">getUser</span><span class="o">(</span><span class="mi">1</span><span class="o">)</span>
</code></pre></div></div>

<p>A <code class="highlighter-rouge">Fetch</code> is just a value, and in order to be able to get its value we need to run it to an <code class="highlighter-rouge">IO</code> first.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nn">cats.effect.IO</span>

<span class="nv">Fetch</span><span class="o">.</span><span class="py">run</span><span class="o">[</span><span class="kt">IO</span><span class="o">](</span><span class="n">fetchUser</span><span class="o">)</span>
</code></pre></div></div>

<p>We can now run the <code class="highlighter-rouge">IO</code> and see its result:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">Fetch</span><span class="o">.</span><span class="py">run</span><span class="o">[</span><span class="kt">IO</span><span class="o">](</span><span class="n">fetchUser</span><span class="o">).</span><span class="py">unsafeRunTimed</span><span class="o">(</span><span class="mf">5.</span><span class="n">seconds</span><span class="o">)</span>
<span class="c1">// res1: Option[User] = Some(value = User(id = 1, username = "@one"))</span>
</code></pre></div></div>

<h3 id="sequencing">Sequencing</h3>

<p>When we have two fetches that depend on each other, we can use <code class="highlighter-rouge">flatMap</code> to combine them. The most straightforward way is to use a for comprehension:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">fetchTwoUsers</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]</span><span class="kt">:</span> <span class="kt">Console:</span> <span class="kt">Temporal</span><span class="o">]</span><span class="k">:</span> <span class="kt">Fetch</span><span class="o">[</span><span class="kt">F</span>, <span class="o">(</span><span class="kt">User</span>, <span class="kt">User</span><span class="o">)]</span> <span class="k">=</span> <span class="k">for</span> <span class="o">{</span>
  <span class="n">aUser</span> <span class="k">&lt;-</span> <span class="nf">getUser</span><span class="o">(</span><span class="mi">1</span><span class="o">)</span>
  <span class="n">anotherUser</span> <span class="k">&lt;-</span> <span class="nf">getUser</span><span class="o">(</span><span class="nv">aUser</span><span class="o">.</span><span class="py">id</span> <span class="o">+</span> <span class="mi">1</span><span class="o">)</span>
<span class="o">}</span> <span class="nf">yield</span> <span class="o">(</span><span class="n">aUser</span><span class="o">,</span> <span class="n">anotherUser</span><span class="o">)</span>
</code></pre></div></div>

<p>When composing fetches with <code class="highlighter-rouge">flatMap</code> we are telling Fetch that the second one depends on the previous one, so it isn’t able to make any optimizations. When running the above fetch, we will query the user data source in two rounds: one for the user with id 1 and another for the user with id 2.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">Fetch</span><span class="o">.</span><span class="py">run</span><span class="o">[</span><span class="kt">IO</span><span class="o">](</span><span class="n">fetchTwoUsers</span><span class="o">).</span><span class="py">unsafeRunTimed</span><span class="o">(</span><span class="mf">5.</span><span class="n">seconds</span><span class="o">)</span>
<span class="c1">// res2: Option[(User, User)] = Some(</span>
<span class="c1">//   value = (User(id = 1, username = "@one"), User(id = 2, username = "@two"))</span>
<span class="c1">// )</span>
</code></pre></div></div>

<h3 id="batching">Batching</h3>

<p>If we combine two independent requests to the same data source, Fetch will
automatically batch them together into a single request. Applicative operations like the product of two fetches
help us tell the library that those fetches are independent, and thus can be batched if they use the same data source:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">fetchProduct</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]</span><span class="kt">:</span> <span class="kt">Console:</span> <span class="kt">Temporal</span><span class="o">]</span><span class="k">:</span> <span class="kt">Fetch</span><span class="o">[</span><span class="kt">F</span>, <span class="o">(</span><span class="kt">User</span>, <span class="kt">User</span><span class="o">)]</span> <span class="k">=</span>
  <span class="o">(</span><span class="nf">getUser</span><span class="o">(</span><span class="mi">1</span><span class="o">),</span> <span class="nf">getUser</span><span class="o">(</span><span class="mi">2</span><span class="o">)).</span><span class="py">tupled</span>
</code></pre></div></div>

<p>Note how both ids (1 and 2) are requested in a single query to the data source when executing the fetch.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">Fetch</span><span class="o">.</span><span class="py">run</span><span class="o">[</span><span class="kt">IO</span><span class="o">](</span><span class="n">fetchProduct</span><span class="o">).</span><span class="py">unsafeRunTimed</span><span class="o">(</span><span class="mf">5.</span><span class="n">seconds</span><span class="o">)</span>
<span class="c1">// res3: Option[(User, User)] = Some(</span>
<span class="c1">//   value = (User(id = 1, username = "@one"), User(id = 2, username = "@two"))</span>
<span class="c1">// )</span>
</code></pre></div></div>

<h3 id="deduplication">Deduplication</h3>

<p>If two independent requests ask for the same identity, Fetch will detect it and deduplicate the id.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">fetchDuped</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]</span><span class="kt">:</span> <span class="kt">Console:</span> <span class="kt">Temporal</span><span class="o">]</span><span class="k">:</span> <span class="kt">Fetch</span><span class="o">[</span><span class="kt">F</span>, <span class="o">(</span><span class="kt">User</span>, <span class="kt">User</span><span class="o">)]</span> <span class="k">=</span>
  <span class="o">(</span><span class="nf">getUser</span><span class="o">(</span><span class="mi">1</span><span class="o">),</span> <span class="nf">getUser</span><span class="o">(</span><span class="mi">1</span><span class="o">)).</span><span class="py">tupled</span>
</code></pre></div></div>

<p>Note that when running the fetch, the identity 1 is only requested once even when it is needed by both fetches.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">Fetch</span><span class="o">.</span><span class="py">run</span><span class="o">[</span><span class="kt">IO</span><span class="o">](</span><span class="n">fetchDuped</span><span class="o">).</span><span class="py">unsafeRunTimed</span><span class="o">(</span><span class="mf">5.</span><span class="n">seconds</span><span class="o">)</span>
<span class="c1">// res4: Option[(User, User)] = Some(</span>
<span class="c1">//   value = (User(id = 1, username = "@one"), User(id = 1, username = "@one"))</span>
<span class="c1">// )</span>
</code></pre></div></div>

<h3 id="caching">Caching</h3>

<p>During the execution of a fetch, previously requested results are implicitly cached. This allows us to write
fetches in a very modular way, asking for all the data they need as if it
was in memory; furthermore, it also avoids re-fetching an identity that may have changed
during the course of a fetch execution, which can lead to inconsistencies in the data.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">fetchCached</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]</span><span class="kt">:</span> <span class="kt">Console:</span> <span class="kt">Temporal</span><span class="o">]</span><span class="k">:</span> <span class="kt">Fetch</span><span class="o">[</span><span class="kt">F</span>, <span class="o">(</span><span class="kt">User</span>, <span class="kt">User</span><span class="o">)]</span> <span class="k">=</span> <span class="k">for</span> <span class="o">{</span>
  <span class="n">aUser</span> <span class="k">&lt;-</span> <span class="nf">getUser</span><span class="o">(</span><span class="mi">1</span><span class="o">)</span>
  <span class="n">anotherUser</span> <span class="k">&lt;-</span> <span class="nf">getUser</span><span class="o">(</span><span class="mi">1</span><span class="o">)</span>
<span class="o">}</span> <span class="nf">yield</span> <span class="o">(</span><span class="n">aUser</span><span class="o">,</span> <span class="n">anotherUser</span><span class="o">)</span>
</code></pre></div></div>

<p>The above fetch asks for the same identity multiple times. Let’s see what happens when executing it.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">Fetch</span><span class="o">.</span><span class="py">run</span><span class="o">[</span><span class="kt">IO</span><span class="o">](</span><span class="n">fetchCached</span><span class="o">).</span><span class="py">unsafeRunTimed</span><span class="o">(</span><span class="mf">5.</span><span class="n">seconds</span><span class="o">)</span>
<span class="c1">// res5: Option[(User, User)] = Some(</span>
<span class="c1">//   value = (User(id = 1, username = "@one"), User(id = 1, username = "@one"))</span>
<span class="c1">// )</span>
</code></pre></div></div>

<p>As you can see, the <code class="highlighter-rouge">User</code> with id 1 was fetched only once in a single round-trip. The next
time it was needed we used the cached versions, thus avoiding another request to the user data
source.</p>

<h2 id="combining-data-from-multiple-sources">Combining data from multiple sources</h2>

<p>Now that we know about some of the optimizations that Fetch can perform to read data efficiently,
let’s look at how we can combine more than one data source.</p>

<p>Imagine that we are rendering a blog and have the following types for posts:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">type</span> <span class="kt">PostId</span> <span class="o">=</span> <span class="nc">Int</span>
<span class="k">case</span> <span class="k">class</span> <span class="nc">Post</span><span class="o">(</span><span class="n">id</span><span class="k">:</span> <span class="kt">PostId</span><span class="o">,</span> <span class="n">author</span><span class="k">:</span> <span class="kt">UserId</span><span class="o">,</span> <span class="n">content</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span>
</code></pre></div></div>

<p>As you can see, every <code class="highlighter-rouge">Post</code> has an author, but it refers to the author by its id. We’ll implement a data source for retrieving a post given a post id.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">val</span> <span class="nv">postDatabase</span><span class="k">:</span> <span class="kt">Map</span><span class="o">[</span><span class="kt">PostId</span>, <span class="kt">Post</span><span class="o">]</span> <span class="k">=</span> <span class="nc">Map</span><span class="o">(</span>
  <span class="mi">1</span> <span class="o">-&gt;</span> <span class="nc">Post</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="s">"An article"</span><span class="o">),</span>
  <span class="mi">2</span> <span class="o">-&gt;</span> <span class="nc">Post</span><span class="o">(</span><span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="s">"Another article"</span><span class="o">),</span>
  <span class="mi">3</span> <span class="o">-&gt;</span> <span class="nc">Post</span><span class="o">(</span><span class="mi">3</span><span class="o">,</span> <span class="mi">4</span><span class="o">,</span> <span class="s">"Yet another article"</span><span class="o">)</span>
<span class="o">)</span>

<span class="k">object</span> <span class="nc">Posts</span> <span class="k">extends</span> <span class="nc">Data</span><span class="o">[</span><span class="kt">PostId</span>, <span class="kt">Post</span><span class="o">]</span> <span class="o">{</span>
  <span class="k">def</span> <span class="nf">name</span> <span class="k">=</span> <span class="s">"Posts"</span>

  <span class="c1">//Calls to `latency` need to sleep and use the console, so we need Console and Temporal (which extends Concurrent) instances</span>
  <span class="k">def</span> <span class="nf">source</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]</span><span class="kt">:</span> <span class="kt">Console:</span> <span class="kt">Temporal</span><span class="o">]</span><span class="k">:</span> <span class="kt">DataSource</span><span class="o">[</span><span class="kt">F</span>, <span class="kt">PostId</span>, <span class="kt">Post</span><span class="o">]</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">DataSource</span><span class="o">[</span><span class="kt">F</span>, <span class="kt">PostId</span>, <span class="kt">Post</span><span class="o">]</span> <span class="o">{</span>
    <span class="k">override</span> <span class="k">def</span> <span class="nf">data</span> <span class="k">=</span> <span class="nc">Posts</span> 

    <span class="k">override</span> <span class="k">def</span> <span class="nf">CF</span> <span class="k">=</span> <span class="nc">Concurrent</span><span class="o">[</span><span class="kt">F</span><span class="o">]</span>

    <span class="k">override</span> <span class="k">def</span> <span class="nf">fetch</span><span class="o">(</span><span class="n">id</span><span class="k">:</span> <span class="kt">PostId</span><span class="o">)</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">Option</span><span class="o">[</span><span class="kt">Post</span><span class="o">]]</span> <span class="k">=</span>
      <span class="n">latency</span><span class="o">[</span><span class="kt">F</span><span class="o">](</span><span class="n">s</span><span class="s">"One Post $id"</span><span class="o">)</span> <span class="o">&gt;&gt;</span> <span class="nv">CF</span><span class="o">.</span><span class="py">pure</span><span class="o">(</span><span class="nv">postDatabase</span><span class="o">.</span><span class="py">get</span><span class="o">(</span><span class="n">id</span><span class="o">))</span>

    <span class="k">override</span> <span class="k">def</span> <span class="nf">batch</span><span class="o">(</span><span class="n">ids</span><span class="k">:</span> <span class="kt">NonEmptyList</span><span class="o">[</span><span class="kt">PostId</span><span class="o">])</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">Map</span><span class="o">[</span><span class="kt">PostId</span>, <span class="kt">Post</span><span class="o">]]</span> <span class="k">=</span>
      <span class="n">latency</span><span class="o">[</span><span class="kt">F</span><span class="o">](</span><span class="n">s</span><span class="s">"Batch Posts $ids"</span><span class="o">)</span> <span class="o">&gt;&gt;</span> <span class="nv">CF</span><span class="o">.</span><span class="py">pure</span><span class="o">(</span><span class="nv">postDatabase</span><span class="o">.</span><span class="py">view</span><span class="o">.</span><span class="py">filterKeys</span><span class="o">(</span><span class="nv">ids</span><span class="o">.</span><span class="py">toList</span><span class="o">.</span><span class="py">toSet</span><span class="o">).</span><span class="py">toMap</span><span class="o">)</span>
  <span class="o">}</span>
<span class="o">}</span>

<span class="k">def</span> <span class="nf">getPost</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]</span><span class="kt">:</span> <span class="kt">Console:</span> <span class="kt">Temporal</span><span class="o">](</span><span class="n">id</span><span class="k">:</span> <span class="kt">PostId</span><span class="o">)</span><span class="k">:</span> <span class="kt">Fetch</span><span class="o">[</span><span class="kt">F</span>, <span class="kt">Post</span><span class="o">]</span> <span class="k">=</span>
  <span class="nc">Fetch</span><span class="o">(</span><span class="n">id</span><span class="o">,</span> <span class="nv">Posts</span><span class="o">.</span><span class="py">source</span><span class="o">)</span>
</code></pre></div></div>

<p>Apart from posts, we are going to add another data source: one for post topics.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">type</span> <span class="kt">PostTopic</span> <span class="o">=</span> <span class="nc">String</span>
</code></pre></div></div>

<p>We’ll implement a data source for retrieving a post topic given a post id.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">object</span> <span class="nc">PostTopics</span> <span class="k">extends</span> <span class="nc">Data</span><span class="o">[</span><span class="kt">Post</span>, <span class="kt">PostTopic</span><span class="o">]</span> <span class="o">{</span>
  <span class="k">def</span> <span class="nf">name</span> <span class="k">=</span> <span class="s">"Post Topics"</span>

  <span class="k">def</span> <span class="nf">source</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]</span><span class="kt">:</span> <span class="kt">Console:</span> <span class="kt">Temporal</span><span class="o">]</span><span class="k">:</span> <span class="kt">DataSource</span><span class="o">[</span><span class="kt">F</span>, <span class="kt">Post</span>, <span class="kt">PostTopic</span><span class="o">]</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">DataSource</span><span class="o">[</span><span class="kt">F</span>, <span class="kt">Post</span>, <span class="kt">PostTopic</span><span class="o">]</span> <span class="o">{</span>
    <span class="k">override</span> <span class="k">def</span> <span class="nf">data</span> <span class="k">=</span> <span class="nc">PostTopics</span> 

    <span class="k">override</span> <span class="k">def</span> <span class="nf">CF</span> <span class="k">=</span> <span class="nc">Concurrent</span><span class="o">[</span><span class="kt">F</span><span class="o">]</span>

    <span class="k">override</span> <span class="k">def</span> <span class="nf">fetch</span><span class="o">(</span><span class="n">id</span><span class="k">:</span> <span class="kt">Post</span><span class="o">)</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">Option</span><span class="o">[</span><span class="kt">PostTopic</span><span class="o">]]</span> <span class="k">=</span> <span class="o">{</span>
      <span class="k">val</span> <span class="nv">topic</span> <span class="k">=</span> <span class="nf">if</span> <span class="o">(</span><span class="nv">id</span><span class="o">.</span><span class="py">id</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span> <span class="s">"monad"</span> <span class="k">else</span> <span class="s">"applicative"</span>
      <span class="n">latency</span><span class="o">[</span><span class="kt">F</span><span class="o">](</span><span class="n">s</span><span class="s">"One Post Topic $id"</span><span class="o">)</span> <span class="o">&gt;&gt;</span> <span class="nv">CF</span><span class="o">.</span><span class="py">pure</span><span class="o">(</span><span class="nc">Option</span><span class="o">(</span><span class="n">topic</span><span class="o">))</span>
    <span class="o">}</span>

    <span class="k">override</span> <span class="k">def</span> <span class="nf">batch</span><span class="o">(</span><span class="n">ids</span><span class="k">:</span> <span class="kt">NonEmptyList</span><span class="o">[</span><span class="kt">Post</span><span class="o">])</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">Map</span><span class="o">[</span><span class="kt">Post</span>, <span class="kt">PostTopic</span><span class="o">]]</span> <span class="k">=</span> <span class="o">{</span>
      <span class="k">val</span> <span class="nv">result</span> <span class="k">=</span> <span class="nv">ids</span><span class="o">.</span><span class="py">toList</span><span class="o">.</span><span class="py">map</span><span class="o">(</span><span class="n">id</span> <span class="k">=&gt;</span> <span class="o">(</span><span class="n">id</span><span class="o">,</span> <span class="nf">if</span> <span class="o">(</span><span class="nv">id</span><span class="o">.</span><span class="py">id</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span> <span class="s">"monad"</span> <span class="k">else</span> <span class="s">"applicative"</span><span class="o">)).</span><span class="py">toMap</span>
      <span class="n">latency</span><span class="o">[</span><span class="kt">F</span><span class="o">](</span><span class="n">s</span><span class="s">"Batch Post Topics $ids"</span><span class="o">)</span> <span class="o">&gt;&gt;</span> <span class="nv">CF</span><span class="o">.</span><span class="py">pure</span><span class="o">(</span><span class="n">result</span><span class="o">)</span>
    <span class="o">}</span>
  <span class="o">}</span>
<span class="o">}</span>

<span class="k">def</span> <span class="nf">getPostTopic</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]</span><span class="kt">:</span> <span class="kt">Console:</span> <span class="kt">Temporal</span><span class="o">](</span><span class="n">post</span><span class="k">:</span> <span class="kt">Post</span><span class="o">)</span><span class="k">:</span> <span class="kt">Fetch</span><span class="o">[</span><span class="kt">F</span>, <span class="kt">PostTopic</span><span class="o">]</span> <span class="k">=</span>
  <span class="nc">Fetch</span><span class="o">(</span><span class="n">post</span><span class="o">,</span> <span class="nv">PostTopics</span><span class="o">.</span><span class="py">source</span><span class="o">)</span>
</code></pre></div></div>

<p>Now that we have multiple sources let’s mix them in the same fetch.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">fetchMulti</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]</span><span class="kt">:</span> <span class="kt">Console:</span> <span class="kt">Temporal</span><span class="o">]</span><span class="k">:</span> <span class="kt">Fetch</span><span class="o">[</span><span class="kt">F</span>, <span class="o">(</span><span class="kt">Post</span>, <span class="kt">PostTopic</span><span class="o">)]</span> <span class="k">=</span> <span class="k">for</span> <span class="o">{</span>
  <span class="n">post</span> <span class="k">&lt;-</span> <span class="nf">getPost</span><span class="o">(</span><span class="mi">1</span><span class="o">)</span>
  <span class="n">topic</span> <span class="k">&lt;-</span> <span class="nf">getPostTopic</span><span class="o">(</span><span class="n">post</span><span class="o">)</span>
<span class="o">}</span> <span class="nf">yield</span> <span class="o">(</span><span class="n">post</span><span class="o">,</span> <span class="n">topic</span><span class="o">)</span>
</code></pre></div></div>

<p>We can now run the previous fetch, querying the posts data source first and the user data source afterwards.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">Fetch</span><span class="o">.</span><span class="py">run</span><span class="o">[</span><span class="kt">IO</span><span class="o">](</span><span class="n">fetchMulti</span><span class="o">).</span><span class="py">unsafeRunTimed</span><span class="o">(</span><span class="mf">5.</span><span class="n">seconds</span><span class="o">)</span>
<span class="c1">// res6: Option[(Post, PostTopic)] = Some(</span>
<span class="c1">//   value = (Post(id = 1, author = 2, content = "An article"), "applicative")</span>
<span class="c1">// )</span>
</code></pre></div></div>

<p>In the previous example, we fetched a post given its id and then fetched its topic. This
data could come from entirely different places, but Fetch makes working with heterogeneous sources
of data very easy.</p>

<h3 id="concurrency">Concurrency</h3>

<p>Combining multiple independent requests to the same data source can have two outcomes:</p>

<ul>
  <li>if the data sources are the same, the request is batched</li>
  <li>otherwise, both data sources are queried at the same time</li>
</ul>

<p>In the following example we are fetching from different data sources so both requests will be
evaluated together.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">fetchConcurrent</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]</span><span class="kt">:</span> <span class="kt">Console:</span> <span class="kt">Temporal</span><span class="o">]</span><span class="k">:</span> <span class="kt">Fetch</span><span class="o">[</span><span class="kt">F</span>, <span class="o">(</span><span class="kt">Post</span>, <span class="kt">User</span><span class="o">)]</span> <span class="k">=</span>
  <span class="o">(</span><span class="nf">getPost</span><span class="o">(</span><span class="mi">1</span><span class="o">),</span> <span class="nf">getUser</span><span class="o">(</span><span class="mi">2</span><span class="o">)).</span><span class="py">tupled</span>
</code></pre></div></div>

<p>The above example combines data from two different sources, and the library knows they are independent.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">Fetch</span><span class="o">.</span><span class="py">run</span><span class="o">[</span><span class="kt">IO</span><span class="o">](</span><span class="n">fetchConcurrent</span><span class="o">).</span><span class="py">unsafeRunTimed</span><span class="o">(</span><span class="mf">5.</span><span class="n">seconds</span><span class="o">)</span>
<span class="c1">// res7: Option[(Post, User)] = Some(</span>
<span class="c1">//   value = (</span>
<span class="c1">//     Post(id = 1, author = 2, content = "An article"),</span>
<span class="c1">//     User(id = 2, username = "@two")</span>
<span class="c1">//   )</span>
<span class="c1">// )</span>
</code></pre></div></div>

<h2 id="auto-batching">Auto-batching</h2>

<p>Fetch supports automatically batching multiple fetch requests in sequence using various combinators.
This means that if you make multiple requests at once using combinators from Cats such as <code class="highlighter-rouge">.sequence</code> or <code class="highlighter-rouge">.traverse</code> you will get your requests as fast as possible, every time.</p>

<p>In Fetch 2.x and 3.1.x, calls to <code class="highlighter-rouge">sequence</code> or <code class="highlighter-rouge">traverse</code> on sequences of fetches will automatically try to batch or run fetches concurrently where possible.
However, in Fetch 3.0.0, we briefly went in the direction of not guaranteeing batches on sequences and introducing explicit batching support to work around this.
In hindsight, we felt that those ideas would be best explored in other projects and have decided to revert behavior to the way it was in 2.x, but keeping the new syntax added so as to not break projects.</p>

<p>Here is an example showing how to batch fetches using <code class="highlighter-rouge">Fetch.batchAll</code></p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">val</span> <span class="nv">listOfFetches</span> <span class="k">=</span> <span class="nc">List</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">).</span><span class="py">map</span><span class="o">(</span><span class="n">getPost</span><span class="o">[</span><span class="kt">IO</span><span class="o">])</span>
<span class="k">val</span> <span class="nv">batchedList</span><span class="k">:</span> <span class="kt">Fetch</span><span class="o">[</span><span class="kt">IO</span>, <span class="kt">List</span><span class="o">[</span><span class="kt">Post</span><span class="o">]]</span> <span class="k">=</span> <span class="nv">Fetch</span><span class="o">.</span><span class="py">batchAll</span><span class="o">(</span><span class="n">listOfFetches</span><span class="k">:</span> <span class="k">_</span><span class="kt">*</span><span class="o">)</span>
</code></pre></div></div>

<p>You can also use helpful syntax by importing <code class="highlighter-rouge">fetch.syntax._</code> for batching sequences, like so:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nn">fetch.syntax._</span>

<span class="c1">//Takes a sequence of fetches and batches them</span>
<span class="k">val</span> <span class="nv">batchedListWithSyntax</span> <span class="k">=</span> <span class="nv">listOfFetches</span><span class="o">.</span><span class="py">batchAll</span>

<span class="c1">//Allows you to supply your own function to batch a sequence as fetches</span>
<span class="k">val</span> <span class="nv">listToBatchWithSyntax</span> <span class="k">=</span> <span class="nc">List</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">).</span><span class="py">batchAllWith</span><span class="o">(</span><span class="n">id</span> <span class="k">=&gt;</span> <span class="n">getPost</span><span class="o">[</span><span class="kt">IO</span><span class="o">](</span><span class="n">id</span><span class="o">))</span>
</code></pre></div></div>

<p>Underneath, <code class="highlighter-rouge">.batchAll</code> and its siblings are synonymous with the methods from Cats named <code class="highlighter-rouge">.sequence</code> or <code class="highlighter-rouge">.traverse</code>, but converting the final result to a <code class="highlighter-rouge">List</code> explicitly afterward.
If you currently use <code class="highlighter-rouge">.sequence</code> or <code class="highlighter-rouge">.traverse</code>, you will automatically batch a sequence of fetches as always, and <code class="highlighter-rouge">.batchAll</code> is there for less cats-heavy usage.</p>

<h1 id="caching-1">Caching</h1>

<p>As we have learned, Fetch caches intermediate results implicitly. You can
provide a prepopulated cache for running a fetch, replay a fetch with the cache of a previous
one, and even implement a custom cache.</p>

<h2 id="prepopulating-a-cache">Prepopulating a cache</h2>

<p>We’ll be using the default in-memory cache, prepopulated with some data. The cache key of an identity
is calculated with the <code class="highlighter-rouge">DataSource</code>’s <code class="highlighter-rouge">name</code> method and the request identity.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">cache</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]</span><span class="kt">:</span> <span class="kt">Concurrent</span><span class="o">]</span> <span class="k">=</span> <span class="nv">InMemoryCache</span><span class="o">.</span><span class="py">from</span><span class="o">[</span><span class="kt">F</span>, <span class="kt">UserId</span>, <span class="kt">User</span><span class="o">](</span>
 <span class="o">(</span><span class="nc">Users</span><span class="o">,</span> <span class="mi">1</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="nc">User</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="s">"purrgrammer"</span><span class="o">)</span>
<span class="o">)</span>
</code></pre></div></div>

<p>We can pass a cache as the second argument when running a fetch with <code class="highlighter-rouge">Fetch.run</code>.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">Fetch</span><span class="o">.</span><span class="py">run</span><span class="o">[</span><span class="kt">IO</span><span class="o">](</span><span class="n">fetchUser</span><span class="o">,</span> <span class="n">cache</span><span class="o">).</span><span class="py">unsafeRunTimed</span><span class="o">(</span><span class="mf">5.</span><span class="n">seconds</span><span class="o">)</span>
<span class="c1">// res8: Option[User] = Some(value = User(id = 1, username = "purrgrammer"))</span>
</code></pre></div></div>

<p>As you can see, when all the data is cached, no query to the data sources is executed since the results are available
in the cache.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">fetchManyUsers</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]</span><span class="kt">:</span> <span class="kt">Console:</span> <span class="kt">Temporal</span><span class="o">]</span><span class="k">:</span> <span class="kt">Fetch</span><span class="o">[</span><span class="kt">F</span>, <span class="kt">List</span><span class="o">[</span><span class="kt">User</span><span class="o">]]</span> <span class="k">=</span>
  <span class="nc">List</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">).</span><span class="py">traverse</span><span class="o">(</span><span class="n">getUser</span><span class="o">[</span><span class="kt">F</span><span class="o">])</span>
</code></pre></div></div>

<p>If only part of the data is cached, the cached data won’t be asked for:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">Fetch</span><span class="o">.</span><span class="py">run</span><span class="o">[</span><span class="kt">IO</span><span class="o">](</span><span class="n">fetchManyUsers</span><span class="o">,</span> <span class="n">cache</span><span class="o">).</span><span class="py">unsafeRunTimed</span><span class="o">(</span><span class="mf">5.</span><span class="n">seconds</span><span class="o">)</span>
<span class="c1">// res9: Option[List[User]] = Some(</span>
<span class="c1">//   value = List(</span>
<span class="c1">//     User(id = 1, username = "purrgrammer"),</span>
<span class="c1">//     User(id = 2, username = "@two"),</span>
<span class="c1">//     User(id = 3, username = "@three")</span>
<span class="c1">//   )</span>
<span class="c1">// )</span>
</code></pre></div></div>

<h2 id="replaying-a-fetch-without-querying-any-data-source">Replaying a fetch without querying any data source</h2>

<p>When running a fetch, we are generally interested in its final result. However, we also have access to the cache once we run a fetch. We can get both the cache and the result using <code class="highlighter-rouge">Fetch.runCache</code> instead of <code class="highlighter-rouge">Fetch.run</code>.</p>

<p>Knowing this, we can replay a fetch reusing the cache of a previous one. The replayed fetch won’t have to call any of the
data sources.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nf">val</span> <span class="o">(</span><span class="n">populatedCache</span><span class="o">,</span> <span class="n">result</span><span class="o">)</span> <span class="k">=</span> <span class="nv">Fetch</span><span class="o">.</span><span class="py">runCache</span><span class="o">[</span><span class="kt">IO</span><span class="o">](</span><span class="n">fetchManyUsers</span><span class="o">).</span><span class="py">unsafeRunSync</span><span class="o">()</span>
<span class="c1">// populatedCache: DataCache[IO] = InMemoryCache(</span>
<span class="c1">//   state = Map(</span>
<span class="c1">//     (repl.MdocSession$MdocApp$Users$@9a59a6e, fetch.DataSourceId@1) -&gt; fetch.DataSourceResult@d3eb82b3,</span>
<span class="c1">//     (repl.MdocSession$MdocApp$Users$@9a59a6e, fetch.DataSourceId@2) -&gt; fetch.DataSourceResult@d43da1de,</span>
<span class="c1">//     (repl.MdocSession$MdocApp$Users$@9a59a6e, fetch.DataSourceId@3) -&gt; fetch.DataSourceResult@30b9ef3f</span>
<span class="c1">//   )</span>
<span class="c1">// )</span>
<span class="c1">// result: List[User] = List(</span>
<span class="c1">//   User(id = 1, username = "@one"),</span>
<span class="c1">//   User(id = 2, username = "@two"),</span>
<span class="c1">//   User(id = 3, username = "@three")</span>
<span class="c1">// )</span>

<span class="nv">Fetch</span><span class="o">.</span><span class="py">run</span><span class="o">[</span><span class="kt">IO</span><span class="o">](</span><span class="n">fetchManyUsers</span><span class="o">,</span> <span class="n">populatedCache</span><span class="o">).</span><span class="py">unsafeRunTimed</span><span class="o">(</span><span class="mf">5.</span><span class="n">seconds</span><span class="o">)</span>
<span class="c1">// res10: Option[List[User]] = Some(</span>
<span class="c1">//   value = List(</span>
<span class="c1">//     User(id = 1, username = "@one"),</span>
<span class="c1">//     User(id = 2, username = "@two"),</span>
<span class="c1">//     User(id = 3, username = "@three")</span>
<span class="c1">//   )</span>
<span class="c1">// )</span>
</code></pre></div></div>

<h2 id="implementing-a-custom-cache">Implementing a custom cache</h2>

<p>The default cache is implemented as an immutable in-memory map, but users are free to use their own caches when running a fetch. Your cache should implement the <code class="highlighter-rouge">DataCache</code> trait, and after that you can pass it to Fetch’s <code class="highlighter-rouge">run</code> methods.</p>

<p>There is no need for the cache to be mutable since fetch executions run in an interpreter that uses the state monad. Note that the <code class="highlighter-rouge">update</code> method in the <code class="highlighter-rouge">DataCache</code> trait yields a new, updated cache.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">trait</span> <span class="nc">DataCache</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]]</span> <span class="o">{</span>
  <span class="k">def</span> <span class="nf">insert</span><span class="o">[</span><span class="kt">I</span>, <span class="kt">A</span><span class="o">](</span><span class="n">i</span><span class="k">:</span> <span class="kt">I</span><span class="o">,</span> <span class="n">v</span><span class="k">:</span> <span class="kt">A</span><span class="o">,</span> <span class="n">d</span><span class="k">:</span> <span class="kt">Data</span><span class="o">[</span><span class="kt">I</span>, <span class="kt">A</span><span class="o">])</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">DataCache</span><span class="o">[</span><span class="kt">F</span><span class="o">]]</span>
  <span class="k">def</span> <span class="nf">lookup</span><span class="o">[</span><span class="kt">I</span>, <span class="kt">A</span><span class="o">](</span><span class="n">i</span><span class="k">:</span> <span class="kt">I</span><span class="o">,</span> <span class="n">d</span><span class="k">:</span> <span class="kt">Data</span><span class="o">[</span><span class="kt">I</span>, <span class="kt">A</span><span class="o">])</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">Option</span><span class="o">[</span><span class="kt">A</span><span class="o">]]</span>
<span class="o">}</span>
</code></pre></div></div>

<p>Let’s implement a cache that forgets everything we store in it.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nn">cats.</span><span class="o">{</span><span class="nc">Applicative</span><span class="o">,</span> <span class="nc">Monad</span><span class="o">}</span>

<span class="k">case</span> <span class="k">class</span> <span class="nc">ForgetfulCache</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]</span> <span class="kt">:</span> <span class="kt">Monad</span><span class="o">]()</span> <span class="k">extends</span> <span class="nc">DataCache</span><span class="o">[</span><span class="kt">F</span><span class="o">]</span> <span class="o">{</span>
  <span class="k">def</span> <span class="nf">insert</span><span class="o">[</span><span class="kt">I</span>, <span class="kt">A</span><span class="o">](</span><span class="n">i</span><span class="k">:</span> <span class="kt">I</span><span class="o">,</span> <span class="n">v</span><span class="k">:</span> <span class="kt">A</span><span class="o">,</span> <span class="n">d</span><span class="k">:</span> <span class="kt">Data</span><span class="o">[</span><span class="kt">I</span>, <span class="kt">A</span><span class="o">])</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">DataCache</span><span class="o">[</span><span class="kt">F</span><span class="o">]]</span> <span class="k">=</span>
    <span class="nc">Applicative</span><span class="o">[</span><span class="kt">F</span><span class="o">].</span><span class="py">pure</span><span class="o">(</span><span class="k">this</span><span class="o">)</span>

  <span class="k">def</span> <span class="nf">lookup</span><span class="o">[</span><span class="kt">I</span>, <span class="kt">A</span><span class="o">](</span><span class="n">i</span><span class="k">:</span> <span class="kt">I</span><span class="o">,</span> <span class="n">ds</span><span class="k">:</span> <span class="kt">Data</span><span class="o">[</span><span class="kt">I</span>, <span class="kt">A</span><span class="o">])</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">Option</span><span class="o">[</span><span class="kt">A</span><span class="o">]]</span> <span class="k">=</span>
    <span class="nc">Applicative</span><span class="o">[</span><span class="kt">F</span><span class="o">].</span><span class="py">pure</span><span class="o">(</span><span class="nc">None</span><span class="o">)</span>
<span class="o">}</span>

<span class="k">def</span> <span class="nf">forgetfulCache</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]</span><span class="kt">:</span> <span class="kt">Concurrent</span><span class="o">]</span> <span class="k">=</span> <span class="nc">ForgetfulCache</span><span class="o">[</span><span class="kt">F</span><span class="o">]()</span>
</code></pre></div></div>

<p>We can now use our implementation of the cache when running a fetch.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">fetchSameTwice</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]</span><span class="kt">:</span> <span class="kt">Console:</span> <span class="kt">Temporal</span><span class="o">]</span><span class="k">:</span> <span class="kt">Fetch</span><span class="o">[</span><span class="kt">F</span>, <span class="o">(</span><span class="kt">User</span>, <span class="kt">User</span><span class="o">)]</span> <span class="k">=</span> <span class="k">for</span> <span class="o">{</span>
  <span class="n">one</span> <span class="k">&lt;-</span> <span class="nf">getUser</span><span class="o">(</span><span class="mi">1</span><span class="o">)</span>
  <span class="n">another</span> <span class="k">&lt;-</span> <span class="nf">getUser</span><span class="o">(</span><span class="mi">1</span><span class="o">)</span>
<span class="o">}</span> <span class="nf">yield</span> <span class="o">(</span><span class="n">one</span><span class="o">,</span> <span class="n">another</span><span class="o">)</span>

<span class="nv">Fetch</span><span class="o">.</span><span class="py">run</span><span class="o">[</span><span class="kt">IO</span><span class="o">](</span><span class="n">fetchSameTwice</span><span class="o">,</span> <span class="n">forgetfulCache</span><span class="o">).</span><span class="py">unsafeRunTimed</span><span class="o">(</span><span class="mf">5.</span><span class="n">seconds</span><span class="o">)</span>
<span class="c1">// res11: Option[(User, User)] = Some(</span>
<span class="c1">//   value = (User(id = 1, username = "@one"), User(id = 1, username = "@one"))</span>
<span class="c1">// )</span>
</code></pre></div></div>

<h1 id="batching-1">Batching</h1>

<p>As we have learned, Fetch performs batched requests whenever it can. It also exposes a couple knobs
for tweaking the maximum batch size and whether multiple batches are run in parallel or sequentially.</p>

<h2 id="maximum-batch-size">Maximum batch size</h2>

<p>When implementing a <code class="highlighter-rouge">DataSource</code>, there is a method we can override called <code class="highlighter-rouge">maxBatchSize</code>. When implementing it
we can specify the maximum size of the batched requests to this data source, let’s try it out:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">object</span> <span class="nc">BatchedUsers</span> <span class="k">extends</span> <span class="nc">Data</span><span class="o">[</span><span class="kt">UserId</span>, <span class="kt">User</span><span class="o">]{</span>
  <span class="k">def</span> <span class="nf">name</span> <span class="k">=</span> <span class="s">"Batched Users"</span>

  <span class="k">def</span> <span class="nf">source</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]</span><span class="kt">:</span> <span class="kt">Console:</span> <span class="kt">Temporal</span><span class="o">]</span><span class="k">:</span> <span class="kt">DataSource</span><span class="o">[</span><span class="kt">F</span>, <span class="kt">UserId</span>, <span class="kt">User</span><span class="o">]</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">DataSource</span><span class="o">[</span><span class="kt">F</span>, <span class="kt">UserId</span>, <span class="kt">User</span><span class="o">]</span> <span class="o">{</span>
    <span class="k">override</span> <span class="k">def</span> <span class="nf">data</span> <span class="k">=</span> <span class="nc">BatchedUsers</span>

    <span class="k">override</span> <span class="k">def</span> <span class="nf">CF</span> <span class="k">=</span> <span class="nc">Concurrent</span><span class="o">[</span><span class="kt">F</span><span class="o">]</span>

    <span class="k">override</span> <span class="k">def</span> <span class="nf">maxBatchSize</span><span class="k">:</span> <span class="kt">Option</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="nc">Some</span><span class="o">(</span><span class="mi">2</span><span class="o">)</span>

    <span class="k">override</span> <span class="k">def</span> <span class="nf">fetch</span><span class="o">(</span><span class="n">id</span><span class="k">:</span> <span class="kt">UserId</span><span class="o">)</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">Option</span><span class="o">[</span><span class="kt">User</span><span class="o">]]</span> <span class="k">=</span>
      <span class="n">latency</span><span class="o">[</span><span class="kt">F</span><span class="o">](</span><span class="n">s</span><span class="s">"One User $id"</span><span class="o">)</span> <span class="o">&gt;&gt;</span> <span class="nv">CF</span><span class="o">.</span><span class="py">pure</span><span class="o">(</span><span class="nv">userDatabase</span><span class="o">.</span><span class="py">get</span><span class="o">(</span><span class="n">id</span><span class="o">))</span>

    <span class="k">override</span> <span class="k">def</span> <span class="nf">batch</span><span class="o">(</span><span class="n">ids</span><span class="k">:</span> <span class="kt">NonEmptyList</span><span class="o">[</span><span class="kt">UserId</span><span class="o">])</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">Map</span><span class="o">[</span><span class="kt">UserId</span>, <span class="kt">User</span><span class="o">]]</span> <span class="k">=</span>
      <span class="n">latency</span><span class="o">[</span><span class="kt">F</span><span class="o">](</span><span class="n">s</span><span class="s">"Batch Users $ids"</span><span class="o">)</span> <span class="o">&gt;&gt;</span> <span class="nv">CF</span><span class="o">.</span><span class="py">pure</span><span class="o">(</span><span class="nv">userDatabase</span><span class="o">.</span><span class="py">view</span><span class="o">.</span><span class="py">filterKeys</span><span class="o">(</span><span class="nv">ids</span><span class="o">.</span><span class="py">toList</span><span class="o">.</span><span class="py">toSet</span><span class="o">).</span><span class="py">toMap</span><span class="o">)</span>
  <span class="o">}</span>
<span class="o">}</span>

<span class="k">def</span> <span class="nf">getBatchedUser</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]</span><span class="kt">:</span> <span class="kt">Console:</span> <span class="kt">Temporal</span><span class="o">](</span><span class="n">id</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span><span class="k">:</span> <span class="kt">Fetch</span><span class="o">[</span><span class="kt">F</span>, <span class="kt">User</span><span class="o">]</span> <span class="k">=</span>
  <span class="nc">Fetch</span><span class="o">(</span><span class="n">id</span><span class="o">,</span> <span class="nv">BatchedUsers</span><span class="o">.</span><span class="py">source</span><span class="o">)</span>
</code></pre></div></div>

<p>We have defined the maximum batch size to be 2, let’s see what happens when running a fetch that needs more
than two users:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">fetchManyBatchedUsers</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]</span><span class="kt">:</span> <span class="kt">Console:</span> <span class="kt">Temporal</span><span class="o">]</span><span class="k">:</span> <span class="kt">Fetch</span><span class="o">[</span><span class="kt">F</span>, <span class="kt">List</span><span class="o">[</span><span class="kt">User</span><span class="o">]]</span> <span class="k">=</span>
  <span class="nc">List</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">4</span><span class="o">).</span><span class="py">traverse</span><span class="o">(</span><span class="n">getBatchedUser</span><span class="o">[</span><span class="kt">F</span><span class="o">])</span>

<span class="nv">Fetch</span><span class="o">.</span><span class="py">run</span><span class="o">[</span><span class="kt">IO</span><span class="o">](</span><span class="n">fetchManyBatchedUsers</span><span class="o">).</span><span class="py">unsafeRunTimed</span><span class="o">(</span><span class="mf">5.</span><span class="n">seconds</span><span class="o">)</span>
<span class="c1">// res12: Option[List[User]] = Some(</span>
<span class="c1">//   value = List(</span>
<span class="c1">//     User(id = 1, username = "@one"),</span>
<span class="c1">//     User(id = 2, username = "@two"),</span>
<span class="c1">//     User(id = 3, username = "@three"),</span>
<span class="c1">//     User(id = 4, username = "@four")</span>
<span class="c1">//   )</span>
<span class="c1">// )</span>
</code></pre></div></div>

<h2 id="batch-execution-strategy">Batch execution strategy</h2>

<p>In the presence of multiple concurrent batches, we can choose between a sequential or parallel execution strategy. By default batches will be run in parallel, but you can tweak this behaviour by overriding <code class="highlighter-rouge">DataSource#batchExection</code>.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">object</span> <span class="nc">SequentialUsers</span> <span class="k">extends</span> <span class="nc">Data</span><span class="o">[</span><span class="kt">UserId</span>, <span class="kt">User</span><span class="o">]{</span>
  <span class="k">def</span> <span class="nf">name</span> <span class="k">=</span> <span class="s">"Sequential Users"</span>

  <span class="k">def</span> <span class="nf">source</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]</span><span class="kt">:</span> <span class="kt">Console:</span> <span class="kt">Temporal</span><span class="o">]</span><span class="k">:</span> <span class="kt">DataSource</span><span class="o">[</span><span class="kt">F</span>, <span class="kt">UserId</span>, <span class="kt">User</span><span class="o">]</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">DataSource</span><span class="o">[</span><span class="kt">F</span>, <span class="kt">UserId</span>, <span class="kt">User</span><span class="o">]</span> <span class="o">{</span>
    <span class="k">override</span> <span class="k">def</span> <span class="nf">data</span> <span class="k">=</span> <span class="nc">SequentialUsers</span>

    <span class="k">override</span> <span class="k">def</span> <span class="nf">CF</span> <span class="k">=</span> <span class="nc">Concurrent</span><span class="o">[</span><span class="kt">F</span><span class="o">]</span>

    <span class="k">override</span> <span class="k">def</span> <span class="nf">maxBatchSize</span><span class="k">:</span> <span class="kt">Option</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="nc">Some</span><span class="o">(</span><span class="mi">2</span><span class="o">)</span>
    <span class="k">override</span> <span class="k">def</span> <span class="nf">batchExecution</span><span class="k">:</span> <span class="kt">BatchExecution</span> <span class="o">=</span> <span class="nc">Sequentially</span> <span class="c1">// defaults to `InParallel`</span>

    <span class="k">override</span> <span class="k">def</span> <span class="nf">fetch</span><span class="o">(</span><span class="n">id</span><span class="k">:</span> <span class="kt">UserId</span><span class="o">)</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">Option</span><span class="o">[</span><span class="kt">User</span><span class="o">]]</span> <span class="k">=</span>
      <span class="n">latency</span><span class="o">[</span><span class="kt">F</span><span class="o">](</span><span class="n">s</span><span class="s">"One User $id"</span><span class="o">)</span> <span class="o">&gt;&gt;</span> <span class="nv">CF</span><span class="o">.</span><span class="py">pure</span><span class="o">(</span><span class="nv">userDatabase</span><span class="o">.</span><span class="py">get</span><span class="o">(</span><span class="n">id</span><span class="o">))</span>

    <span class="k">override</span> <span class="k">def</span> <span class="nf">batch</span><span class="o">(</span><span class="n">ids</span><span class="k">:</span> <span class="kt">NonEmptyList</span><span class="o">[</span><span class="kt">UserId</span><span class="o">])</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">Map</span><span class="o">[</span><span class="kt">UserId</span>, <span class="kt">User</span><span class="o">]]</span> <span class="k">=</span>
      <span class="n">latency</span><span class="o">[</span><span class="kt">F</span><span class="o">](</span><span class="n">s</span><span class="s">"Batch Users $ids"</span><span class="o">)</span> <span class="o">&gt;&gt;</span> <span class="nv">CF</span><span class="o">.</span><span class="py">pure</span><span class="o">(</span><span class="nv">userDatabase</span><span class="o">.</span><span class="py">view</span><span class="o">.</span><span class="py">filterKeys</span><span class="o">(</span><span class="nv">ids</span><span class="o">.</span><span class="py">toList</span><span class="o">.</span><span class="py">toSet</span><span class="o">).</span><span class="py">toMap</span><span class="o">)</span>
  <span class="o">}</span>
<span class="o">}</span>

<span class="k">def</span> <span class="nf">getSequentialUser</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]</span><span class="kt">:</span> <span class="kt">Console:</span> <span class="kt">Temporal</span><span class="o">](</span><span class="n">id</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span><span class="k">:</span> <span class="kt">Fetch</span><span class="o">[</span><span class="kt">F</span>, <span class="kt">User</span><span class="o">]</span> <span class="k">=</span>
  <span class="nc">Fetch</span><span class="o">(</span><span class="n">id</span><span class="o">,</span> <span class="nv">SequentialUsers</span><span class="o">.</span><span class="py">source</span><span class="o">)</span>
</code></pre></div></div>

<p>We have defined the maximum batch size to be 2 and the batch execution to be sequential, let’s see what happens when running a fetch that needs more than one batch:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">fetchManySeqBatchedUsers</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]</span><span class="kt">:</span> <span class="kt">Console:</span> <span class="kt">Temporal</span><span class="o">]</span><span class="k">:</span> <span class="kt">Fetch</span><span class="o">[</span><span class="kt">F</span>, <span class="kt">List</span><span class="o">[</span><span class="kt">User</span><span class="o">]]</span> <span class="k">=</span>
  <span class="nc">List</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">4</span><span class="o">).</span><span class="py">traverse</span><span class="o">(</span><span class="n">getSequentialUser</span><span class="o">[</span><span class="kt">F</span><span class="o">])</span>

<span class="nv">Fetch</span><span class="o">.</span><span class="py">run</span><span class="o">[</span><span class="kt">IO</span><span class="o">](</span><span class="n">fetchManySeqBatchedUsers</span><span class="o">).</span><span class="py">unsafeRunTimed</span><span class="o">(</span><span class="mf">5.</span><span class="n">seconds</span><span class="o">)</span>
<span class="c1">// res13: Option[List[User]] = Some(</span>
<span class="c1">//   value = List(</span>
<span class="c1">//     User(id = 1, username = "@one"),</span>
<span class="c1">//     User(id = 2, username = "@two"),</span>
<span class="c1">//     User(id = 3, username = "@three"),</span>
<span class="c1">//     User(id = 4, username = "@four")</span>
<span class="c1">//   )</span>
<span class="c1">// )</span>
</code></pre></div></div>

<h1 id="error-handling">Error handling</h1>

<p>Fetch is used for reading data from remote sources and the queries we perform can and will fail at some point. There are many things that can
go wrong:</p>
<ul>
  <li>an exception can be thrown by client code of certain data sources</li>
  <li>an identity may be missing</li>
  <li>the data source may be temporarily available</li>
</ul>

<p>Since the error cases are plenty and can’t be anticipated Fetch errors are represented by the <code class="highlighter-rouge">FetchException</code> trait, which extends <code class="highlighter-rouge">Throwable</code>.
Currently fetch defines <code class="highlighter-rouge">FetchException</code> cases for missing identities and arbitrary exceptions but you can extend <code class="highlighter-rouge">FetchException</code> with any error
you want.</p>

<h2 id="exceptions">Exceptions</h2>

<p>What happens if we run a fetch and fails with an exception? We’ll create a fetch that always fails to learn about it.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">fetchException</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]</span><span class="kt">:</span> <span class="kt">Applicative</span><span class="o">]</span><span class="k">:</span> <span class="kt">Fetch</span><span class="o">[</span><span class="kt">F</span>, <span class="kt">User</span><span class="o">]</span> <span class="k">=</span>
  <span class="nv">Fetch</span><span class="o">.</span><span class="py">error</span><span class="o">(</span><span class="k">new</span> <span class="nc">Exception</span><span class="o">(</span><span class="s">"Oh noes"</span><span class="o">))</span>
</code></pre></div></div>

<p>If we try to execute to <code class="highlighter-rouge">IO</code> the exception will be thrown wrapped in a <code class="highlighter-rouge">fetch.UnhandledException</code>.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">Fetch</span><span class="o">.</span><span class="py">run</span><span class="o">[</span><span class="kt">IO</span><span class="o">](</span><span class="n">fetchException</span><span class="o">).</span><span class="py">unsafeRunTimed</span><span class="o">(</span><span class="mf">5.</span><span class="n">seconds</span><span class="o">)</span>
<span class="c1">// fetch.package$UnhandledException</span>
</code></pre></div></div>

<p>A safer version would use Cats’ <code class="highlighter-rouge">.attempt</code> method:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">Fetch</span><span class="o">.</span><span class="py">run</span><span class="o">[</span><span class="kt">IO</span><span class="o">](</span><span class="n">fetchException</span><span class="o">).</span><span class="py">attempt</span><span class="o">.</span><span class="py">unsafeRunTimed</span><span class="o">(</span><span class="mf">5.</span><span class="n">seconds</span><span class="o">)</span>
<span class="c1">// res14: Option[Either[Throwable, User]] = Some(</span>
<span class="c1">//   value = Left(</span>
<span class="c1">//     value = UnhandledException(</span>
<span class="c1">//       e = java.lang.Exception: Oh noes,</span>
<span class="c1">//       log = FetchLog(q = Queue())</span>
<span class="c1">//     )</span>
<span class="c1">//   )</span>
<span class="c1">// )</span>
</code></pre></div></div>

<h3 id="debugging-exceptions">Debugging exceptions</h3>

<p>Using fetch’s debugging facilities, we can visualize a failed fetch’s execution up until the point where it failed. Let’s create
a fetch that fails after a couple rounds to see it in action:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">failingFetch</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]</span><span class="kt">:</span> <span class="kt">Console:</span> <span class="kt">Temporal</span><span class="o">]</span><span class="k">:</span> <span class="kt">Fetch</span><span class="o">[</span><span class="kt">F</span>, <span class="kt">String</span><span class="o">]</span> <span class="k">=</span> <span class="k">for</span> <span class="o">{</span>
  <span class="n">a</span> <span class="k">&lt;-</span> <span class="nf">getUser</span><span class="o">(</span><span class="mi">1</span><span class="o">)</span>
  <span class="n">b</span> <span class="k">&lt;-</span> <span class="nf">getUser</span><span class="o">(</span><span class="mi">2</span><span class="o">)</span>
  <span class="n">c</span> <span class="k">&lt;-</span> <span class="n">fetchException</span><span class="o">[</span><span class="kt">F</span><span class="o">]</span>
<span class="o">}</span> <span class="k">yield</span> <span class="n">s</span><span class="s">"${a.username} loves ${b.username}"</span>

<span class="k">val</span> <span class="nv">result2</span><span class="k">:</span> <span class="kt">IO</span><span class="o">[</span><span class="kt">Either</span><span class="o">[</span><span class="kt">Throwable</span>, <span class="o">(</span><span class="kt">Log</span>, <span class="kt">String</span><span class="o">)]]</span> <span class="k">=</span> <span class="nv">Fetch</span><span class="o">.</span><span class="py">runLog</span><span class="o">[</span><span class="kt">IO</span><span class="o">](</span><span class="n">failingFetch</span><span class="o">).</span><span class="py">attempt</span>
</code></pre></div></div>

<p>Now let’s use the <code class="highlighter-rouge">fetch.debug.describe</code> function for describing the error if we find one:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nn">fetch.debug.describe</span>

<span class="k">val</span> <span class="nv">value</span><span class="k">:</span> <span class="kt">Either</span><span class="o">[</span><span class="kt">Throwable</span>, <span class="o">(</span><span class="kt">Log</span>, <span class="kt">String</span><span class="o">)]</span> <span class="k">=</span> <span class="nv">result2</span><span class="o">.</span><span class="py">unsafeRunSync</span><span class="o">()</span>
<span class="c1">// value: Either[Throwable, (Log, String)] = Left(</span>
<span class="c1">//   value = UnhandledException(</span>
<span class="c1">//     e = java.lang.Exception: Oh noes,</span>
<span class="c1">//     log = FetchLog(</span>
<span class="c1">//       q = Queue(</span>
<span class="c1">//         Round(</span>
<span class="c1">//           queries = List(</span>
<span class="c1">//             Request(</span>
<span class="c1">//               request = FetchOne(</span>
<span class="c1">//                 id = 1,</span>
<span class="c1">//                 data = repl.MdocSession$MdocApp$Users$@9a59a6e,</span>
<span class="c1">//                 cached = false</span>
<span class="c1">//               ),</span>
<span class="c1">//               start = 719048L,</span>
<span class="c1">//               end = 719149L</span>
<span class="c1">//             )</span>
<span class="c1">//           )</span>
<span class="c1">//         ),</span>
<span class="c1">//         Round(</span>
<span class="c1">//           queries = List(</span>
<span class="c1">//             Request(</span>
<span class="c1">//               request = FetchOne(</span>
<span class="c1">//                 id = 2,</span>
<span class="c1">//                 data = repl.MdocSession$MdocApp$Users$@9a59a6e,</span>
<span class="c1">//                 cached = false</span>
<span class="c1">//               ),</span>
<span class="c1">//               start = 719154L,</span>
<span class="c1">//               end = 719255L</span>
<span class="c1">//             )</span>
<span class="c1">//           )</span>
<span class="c1">//         )</span>
<span class="c1">//       )</span>
<span class="c1">//     )</span>
<span class="c1">//   )</span>
<span class="c1">// )</span>

<span class="nf">println</span><span class="o">(</span><span class="nv">value</span><span class="o">.</span><span class="py">fold</span><span class="o">(</span><span class="n">describe</span><span class="o">,</span> <span class="nv">_</span><span class="o">.</span><span class="py">toString</span><span class="o">))</span>
<span class="c1">// [ERROR] Unhandled `java.lang.Exception`: 'Oh noes', fetch interrupted after 2 rounds</span>
<span class="c1">// Fetch execution 🕛 0.21 seconds</span>
<span class="c1">//   </span>
<span class="c1">//     [Round 1] 🕛 0.10 seconds</span>
<span class="c1">//       [Fetch one] From `Users` with id 1 cached false 🕛 0.10 seconds</span>
<span class="c1">//     [Round 2] 🕛 0.10 seconds</span>
<span class="c1">//       [Fetch one] From `Users` with id 2 cached false 🕛 0.10 seconds</span>
</code></pre></div></div>

<p>As you can see in the output from <code class="highlighter-rouge">describe</code>, the fetch stopped due to a <code class="highlighter-rouge">java.lang.Exception</code> after succesfully executing two
rounds for getting users 1 and 2.</p>

<h2 id="missing-identities">Missing identities</h2>

<p>You’ve probably noticed that <code class="highlighter-rouge">DataSource.fetch</code> and <code class="highlighter-rouge">DataSource.batch</code> return types help Fetch know if any requested
identity was not found. Whenever an identity cannot be found, the fetch execution will fail with an instance of <code class="highlighter-rouge">MissingIdentity</code>.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">missingUser</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]</span><span class="kt">:</span> <span class="kt">Console:</span> <span class="kt">Temporal</span><span class="o">]</span> <span class="k">=</span>
  <span class="nf">getUser</span><span class="o">(</span><span class="mi">5</span><span class="o">)</span>

<span class="k">val</span> <span class="nv">result3</span><span class="k">:</span> <span class="kt">IO</span><span class="o">[</span><span class="kt">Either</span><span class="o">[</span><span class="kt">Throwable</span>, <span class="o">(</span><span class="kt">Log</span>, <span class="kt">User</span><span class="o">)]]</span> <span class="k">=</span> <span class="nv">Fetch</span><span class="o">.</span><span class="py">runLog</span><span class="o">[</span><span class="kt">IO</span><span class="o">](</span><span class="n">missingUser</span><span class="o">).</span><span class="py">attempt</span>
</code></pre></div></div>

<p>And now we can execute the fetch and describe its execution:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">val</span> <span class="nv">value2</span><span class="k">:</span> <span class="kt">Either</span><span class="o">[</span><span class="kt">Throwable</span>, <span class="o">(</span><span class="kt">Log</span>, <span class="kt">User</span><span class="o">)]</span> <span class="k">=</span> <span class="nv">result3</span><span class="o">.</span><span class="py">unsafeRunSync</span><span class="o">()</span>
<span class="c1">// value2: Either[Throwable, (Log, User)] = Left(</span>
<span class="c1">//   value = MissingIdentity(</span>
<span class="c1">//     i = 5,</span>
<span class="c1">//     request = FetchOne(</span>
<span class="c1">//       id = 5,</span>
<span class="c1">//       data = repl.MdocSession$MdocApp$Users$@9a59a6e,</span>
<span class="c1">//       cached = false</span>
<span class="c1">//     ),</span>
<span class="c1">//     log = FetchLog(</span>
<span class="c1">//       q = Queue(</span>
<span class="c1">//         Round(</span>
<span class="c1">//           queries = List(</span>
<span class="c1">//             Request(</span>
<span class="c1">//               request = FetchOne(</span>
<span class="c1">//                 id = 5,</span>
<span class="c1">//                 data = repl.MdocSession$MdocApp$Users$@9a59a6e,</span>
<span class="c1">//                 cached = false</span>
<span class="c1">//               ),</span>
<span class="c1">//               start = 719298L,</span>
<span class="c1">//               end = 719400L</span>
<span class="c1">//             )</span>
<span class="c1">//           )</span>
<span class="c1">//         )</span>
<span class="c1">//       )</span>
<span class="c1">//     )</span>
<span class="c1">//   )</span>
<span class="c1">// )</span>

<span class="nf">println</span><span class="o">(</span><span class="nv">value2</span><span class="o">.</span><span class="py">fold</span><span class="o">(</span><span class="n">describe</span><span class="o">,</span> <span class="nv">_</span><span class="o">.</span><span class="py">toString</span><span class="o">))</span>
<span class="c1">// [ERROR] Identity with id `5` for data source `Users` not found, fetch interrupted after 1 rounds</span>
<span class="c1">// Fetch execution 🕛 0.10 seconds</span>
<span class="c1">//   </span>
<span class="c1">//     [Round 1] 🕛 0.10 seconds</span>
<span class="c1">//       [Fetch one] From `Users` with id 5 cached false 🕛 0.10 seconds</span>
</code></pre></div></div>

<p>As you can see in the output, the identity <code class="highlighter-rouge">5</code> for the user source was not found, thus the fetch failed without executing any rounds.
<code class="highlighter-rouge">MissingIdentity</code> also allows you to access the fetch request that was in progress when the error happened.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">value2</span> <span class="k">match</span> <span class="o">{</span>
  <span class="k">case</span> <span class="nc">Left</span><span class="o">(</span><span class="n">mi</span> <span class="k">@</span> <span class="nc">MissingIdentity</span><span class="o">(</span><span class="n">id</span><span class="o">,</span> <span class="n">q</span><span class="o">,</span> <span class="n">log</span><span class="o">))</span> <span class="k">=&gt;</span> <span class="o">{</span>
    <span class="nf">println</span><span class="o">(</span><span class="s">"Data: "</span> <span class="o">+</span> <span class="nv">q</span><span class="o">.</span><span class="py">data</span><span class="o">.</span><span class="py">name</span><span class="o">)</span>
    <span class="nf">println</span><span class="o">(</span><span class="s">"Identity: "</span> <span class="o">+</span> <span class="n">id</span><span class="o">)</span>

    <span class="nf">println</span><span class="o">(</span><span class="nf">describe</span><span class="o">(</span><span class="n">log</span><span class="o">))</span>
  <span class="o">}</span>
  <span class="k">case</span> <span class="k">_</span> <span class="k">=&gt;</span>
<span class="o">}</span>
<span class="c1">// Data: Users</span>
<span class="c1">// Identity: 5</span>
<span class="c1">// Fetch execution 🕛 0.10 seconds</span>
<span class="c1">// </span>
<span class="c1">//   [Round 1] 🕛 0.10 seconds</span>
<span class="c1">//     [Fetch one] From `Users` with id 5 cached false 🕛 0.10 seconds</span>
</code></pre></div></div>

<h1 id="syntax">Syntax</h1>

<h2 id="companion-object">Companion object</h2>

<p>We’ve been using Cats’ syntax and <code class="highlighter-rouge">fetch.syntax</code> throughout the examples since it’s more concise and general than the
methods in the <code class="highlighter-rouge">Fetch</code> companion object. However, you can use the methods in the companion object
directly.</p>

<p>Note that using cats syntax gives you a plethora of combinators, much richer that what the companion object provides.</p>

<h3 id="pure">pure</h3>

<p>Plain values can be lifted to the Fetch monad with <code class="highlighter-rouge">Fetch#pure</code>:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">fetchPure</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]</span><span class="kt">:</span> <span class="kt">Applicative</span><span class="o">]</span><span class="k">:</span> <span class="kt">Fetch</span><span class="o">[</span><span class="kt">F</span>, <span class="kt">Int</span><span class="o">]</span> <span class="k">=</span>
  <span class="nv">Fetch</span><span class="o">.</span><span class="py">pure</span><span class="o">(</span><span class="mi">42</span><span class="o">)</span>
</code></pre></div></div>

<p>Executing a pure fetch doesn’t query any data source, as expected.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">Fetch</span><span class="o">.</span><span class="py">run</span><span class="o">[</span><span class="kt">IO</span><span class="o">](</span><span class="n">fetchPure</span><span class="o">).</span><span class="py">unsafeRunTimed</span><span class="o">(</span><span class="mf">5.</span><span class="n">seconds</span><span class="o">)</span>
<span class="c1">// res18: Option[Int] = Some(value = 42)</span>
</code></pre></div></div>

<h3 id="error">error</h3>

<p>Errors can also be lifted to the Fetch monad via <code class="highlighter-rouge">Fetch#error</code>.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">fetchFail</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]</span><span class="kt">:</span> <span class="kt">Applicative</span><span class="o">]</span><span class="k">:</span> <span class="kt">Fetch</span><span class="o">[</span><span class="kt">F</span>, <span class="kt">Int</span><span class="o">]</span> <span class="k">=</span>
  <span class="nv">Fetch</span><span class="o">.</span><span class="py">error</span><span class="o">(</span><span class="k">new</span> <span class="nc">Exception</span><span class="o">(</span><span class="s">"Something went terribly wrong"</span><span class="o">))</span>
</code></pre></div></div>

<p>Note that interpreting an errorful fetch can throw an exception.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">Fetch</span><span class="o">.</span><span class="py">run</span><span class="o">[</span><span class="kt">IO</span><span class="o">](</span><span class="n">fetchFail</span><span class="o">).</span><span class="py">unsafeRunTimed</span><span class="o">(</span><span class="mf">5.</span><span class="n">seconds</span><span class="o">)</span>
<span class="c1">// fetch.package$UnhandledException</span>
</code></pre></div></div>

<h3 id="batchall">batchAll</h3>

<p>The <code class="highlighter-rouge">Fetch.batchAll</code> function can be ran on any <code class="highlighter-rouge">Seq[Fetch[F, A]]</code> to turn it into a <code class="highlighter-rouge">Fetch[F, List[A]]</code>.
It works similarly to calling <code class="highlighter-rouge">.sequence</code> on a sequence of fetches, only it tries to batch them where possible.
You can also use <code class="highlighter-rouge">.batchAllWith</code> which works similarly to <code class="highlighter-rouge">.traverse</code> in that it works just like <code class="highlighter-rouge">.map</code> followed by <code class="highlighter-rouge">.batchAll</code>.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">//Longer, manual syntax for batching lists of fetches</span>
<span class="k">val</span> <span class="nv">batchAllManual</span> <span class="k">=</span> <span class="nv">Fetch</span><span class="o">.</span><span class="py">batchAll</span><span class="o">(</span><span class="nc">List</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">).</span><span class="py">map</span><span class="o">(</span><span class="n">getPost</span><span class="o">[</span><span class="kt">IO</span><span class="o">])</span><span class="k">:</span> <span class="k">_</span><span class="kt">*</span><span class="o">)</span>

<span class="c1">//Handy, smaller syntax directly on your list that works like .sequence</span>
<span class="k">val</span> <span class="nv">batchAllWithSyntax</span> <span class="k">=</span> <span class="nc">List</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">).</span><span class="py">map</span><span class="o">(</span><span class="n">getPost</span><span class="o">[</span><span class="kt">IO</span><span class="o">]).</span><span class="py">batchAll</span>

<span class="c1">//Similar syntax that works like .traverse, allowing you to pass a function</span>
<span class="k">val</span> <span class="nv">batchAllDifferentSyntax</span> <span class="k">=</span> <span class="nc">List</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">).</span><span class="py">batchAllWith</span><span class="o">(</span><span class="n">getPost</span><span class="o">[</span><span class="kt">IO</span><span class="o">])</span>
</code></pre></div></div>

<h2 id="cats">cats</h2>

<p>Fetch is built using Cats’ data types and typeclasses and thus works out of the box with
cats syntax. Using Cats’ syntax, we can make fetch declarations more concise, without
the need to use the combinators in the <code class="highlighter-rouge">Fetch</code> companion object.</p>

<p>Fetch provides its own instance of <code class="highlighter-rouge">Applicative[Fetch]</code>. Whenever we use applicative
operations on more than one <code class="highlighter-rouge">Fetch</code>, we know that the fetches are independent meaning
we can perform optimizations such as batching and concurrent requests.</p>

<p>If we were to use the default <code class="highlighter-rouge">Applicative[Fetch]</code> operations, which are implemented in terms of <code class="highlighter-rouge">flatMap</code>,
we wouldn’t have information about the independency of multiple fetches.</p>

<h3 id="applicative">Applicative</h3>

<p>The tuple apply syntax allows us to combine multiple independent fetches, even when they
are from different types, and apply a pure function to their results. We can use it
as a more powerful alternative to the <code class="highlighter-rouge">product</code> method:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">fetchThree</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]</span><span class="kt">:</span> <span class="kt">Console:</span> <span class="kt">Temporal</span><span class="o">]</span><span class="k">:</span> <span class="kt">Fetch</span><span class="o">[</span><span class="kt">F</span>, <span class="o">(</span><span class="kt">Post</span>, <span class="kt">User</span>, <span class="kt">Post</span><span class="o">)]</span> <span class="k">=</span>
  <span class="o">(</span><span class="nf">getPost</span><span class="o">(</span><span class="mi">1</span><span class="o">),</span> <span class="nf">getUser</span><span class="o">(</span><span class="mi">2</span><span class="o">),</span> <span class="nf">getPost</span><span class="o">(</span><span class="mi">2</span><span class="o">)).</span><span class="py">tupled</span>
</code></pre></div></div>

<p>Notice how the queries to posts are batched.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">Fetch</span><span class="o">.</span><span class="py">run</span><span class="o">[</span><span class="kt">IO</span><span class="o">](</span><span class="n">fetchThree</span><span class="o">).</span><span class="py">unsafeRunTimed</span><span class="o">(</span><span class="mf">5.</span><span class="n">seconds</span><span class="o">)</span>
<span class="c1">// res19: Option[(Post, User, Post)] = Some(</span>
<span class="c1">//   value = (</span>
<span class="c1">//     Post(id = 1, author = 2, content = "An article"),</span>
<span class="c1">//     User(id = 2, username = "@two"),</span>
<span class="c1">//     Post(id = 2, author = 3, content = "Another article")</span>
<span class="c1">//   )</span>
<span class="c1">// )</span>
</code></pre></div></div>

<p>More interestingly, we can use it to apply a pure function to the results of various
fetches.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">fetchFriends</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]</span><span class="kt">:</span> <span class="kt">Console:</span> <span class="kt">Temporal</span><span class="o">]</span><span class="k">:</span> <span class="kt">Fetch</span><span class="o">[</span><span class="kt">F</span>, <span class="kt">String</span><span class="o">]</span> <span class="k">=</span> <span class="o">(</span><span class="nf">getUser</span><span class="o">(</span><span class="mi">1</span><span class="o">),</span> <span class="nf">getUser</span><span class="o">(</span><span class="mi">2</span><span class="o">)).</span><span class="py">mapN</span> <span class="o">{</span> <span class="o">(</span><span class="n">one</span><span class="o">,</span> <span class="n">other</span><span class="o">)</span> <span class="k">=&gt;</span>
  <span class="n">s</span><span class="s">"${one.username} is friends with ${other.username}"</span>
<span class="o">}</span>

<span class="nv">Fetch</span><span class="o">.</span><span class="py">run</span><span class="o">[</span><span class="kt">IO</span><span class="o">](</span><span class="n">fetchFriends</span><span class="o">).</span><span class="py">unsafeRunTimed</span><span class="o">(</span><span class="mf">5.</span><span class="n">seconds</span><span class="o">)</span>
<span class="c1">// res20: Option[String] = Some(value = "@one is friends with @two")</span>
</code></pre></div></div>

<h1 id="debugging">Debugging</h1>

<p>We have introduced the handy <code class="highlighter-rouge">fetch.debug.describe</code> function for debugging errors, but it can do more than that. It can also give you a detailed description of
a fetch execution given an execution log.</p>

<p>Add the following line to your dependencies for including Fetch’s debugging facilities:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="s">"com.47deg"</span> <span class="o">%%</span> <span class="s">"fetch-debug"</span> <span class="o">%</span> <span class="s">"3.1.2"</span>
</code></pre></div></div>

<h2 id="fetch-execution">Fetch execution</h2>

<p>We are going to create an interesting fetch that applies all the optimizations available (caching, batching and concurrent request) for ilustrating how we can
visualize fetch executions using the execution log.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">batched</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]</span><span class="kt">:</span> <span class="kt">Console:</span> <span class="kt">Temporal</span><span class="o">]</span><span class="k">:</span> <span class="kt">Fetch</span><span class="o">[</span><span class="kt">F</span>, <span class="kt">List</span><span class="o">[</span><span class="kt">User</span><span class="o">]]</span> <span class="k">=</span>
  <span class="nc">List</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">).</span><span class="py">traverse</span><span class="o">(</span><span class="n">getUser</span><span class="o">[</span><span class="kt">F</span><span class="o">])</span>

<span class="k">def</span> <span class="nf">cached</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]</span><span class="kt">:</span> <span class="kt">Console:</span> <span class="kt">Temporal</span><span class="o">]</span><span class="k">:</span> <span class="kt">Fetch</span><span class="o">[</span><span class="kt">F</span>, <span class="kt">User</span><span class="o">]</span> <span class="k">=</span>
  <span class="nf">getUser</span><span class="o">(</span><span class="mi">2</span><span class="o">)</span>

<span class="k">def</span> <span class="nf">notCached</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]</span><span class="kt">:</span> <span class="kt">Console:</span> <span class="kt">Temporal</span><span class="o">]</span><span class="k">:</span> <span class="kt">Fetch</span><span class="o">[</span><span class="kt">F</span>, <span class="kt">User</span><span class="o">]</span> <span class="k">=</span>
  <span class="nf">getUser</span><span class="o">(</span><span class="mi">4</span><span class="o">)</span>

<span class="k">def</span> <span class="nf">concurrent</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]</span><span class="kt">:</span> <span class="kt">Console:</span> <span class="kt">Temporal</span><span class="o">]</span><span class="k">:</span> <span class="kt">Fetch</span><span class="o">[</span><span class="kt">F</span>, <span class="o">(</span><span class="kt">List</span><span class="o">[</span><span class="kt">User</span><span class="o">]</span>, <span class="kt">List</span><span class="o">[</span><span class="kt">Post</span><span class="o">])]</span> <span class="k">=</span>
  <span class="o">(</span><span class="nc">List</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">).</span><span class="py">traverse</span><span class="o">(</span><span class="n">getUser</span><span class="o">[</span><span class="kt">F</span><span class="o">]),</span> <span class="nc">List</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">).</span><span class="py">traverse</span><span class="o">(</span><span class="n">getPost</span><span class="o">[</span><span class="kt">F</span><span class="o">])).</span><span class="py">tupled</span>

<span class="k">def</span> <span class="nf">interestingFetch</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]</span><span class="kt">:</span> <span class="kt">Console:</span> <span class="kt">Temporal</span><span class="o">]</span><span class="k">:</span> <span class="kt">Fetch</span><span class="o">[</span><span class="kt">F</span>, <span class="kt">String</span><span class="o">]</span> <span class="k">=</span>
  <span class="n">batched</span> <span class="o">&gt;&gt;</span> <span class="n">cached</span> <span class="o">&gt;&gt;</span> <span class="n">notCached</span> <span class="o">&gt;&gt;</span> <span class="n">concurrent</span> <span class="o">&gt;&gt;</span> <span class="nv">Fetch</span><span class="o">.</span><span class="py">pure</span><span class="o">(</span><span class="s">"done"</span><span class="o">)</span>
</code></pre></div></div>

<p>Now that we have the fetch let’s run it, get the log and visualize its execution using the <code class="highlighter-rouge">describe</code> function:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">val</span> <span class="nv">io</span> <span class="k">=</span> <span class="nv">Fetch</span><span class="o">.</span><span class="py">runLog</span><span class="o">[</span><span class="kt">IO</span><span class="o">](</span><span class="n">interestingFetch</span><span class="o">)</span>
<span class="c1">// io: IO[(Log, String)] = FlatMap(</span>
<span class="c1">//   ioe = Map(</span>
<span class="c1">//     ioe = FlatMap(</span>
<span class="c1">//       ioe = Delay(</span>
<span class="c1">//         thunk = cats.effect.IO$$$Lambda$16324/0x000000010486d840@59ed9da6,</span>
<span class="c1">//         event = cats.effect.tracing.TracingEvent$StackTrace</span>
<span class="c1">//       ),</span>
<span class="c1">//       f = cats.FlatMap$$Lambda$16444/0x0000000104945040@738c6589,</span>
<span class="c1">//       event = cats.effect.tracing.TracingEvent$StackTrace</span>
<span class="c1">//     ),</span>
<span class="c1">//     f = cats.SemigroupalArityFunctions$$Lambda$16445/0x0000000104944840@278a950b,</span>
<span class="c1">//     event = cats.effect.tracing.TracingEvent$StackTrace</span>
<span class="c1">//   ),</span>
<span class="c1">//   f = fetch.package$Fetch$FetchRunnerLog$$$Lambda$16520/0x000000010498c040@15839829,</span>
<span class="c1">//   event = cats.effect.tracing.TracingEvent$StackTrace</span>
<span class="c1">// )</span>

<span class="nf">val</span> <span class="o">(</span><span class="n">log</span><span class="o">,</span> <span class="n">result4</span><span class="o">)</span> <span class="k">=</span> <span class="nv">io</span><span class="o">.</span><span class="py">unsafeRunSync</span><span class="o">()</span>
<span class="c1">// log: Log = FetchLog(</span>
<span class="c1">//   q = Queue(</span>
<span class="c1">//     Round(</span>
<span class="c1">//       queries = List(</span>
<span class="c1">//         Request(</span>
<span class="c1">//           request = Batch(</span>
<span class="c1">//             ids = NonEmptyList(head = 1, tail = List(2)),</span>
<span class="c1">//             data = repl.MdocSession$MdocApp$Users$@9a59a6e,</span>
<span class="c1">//             cached = false</span>
<span class="c1">//           ),</span>
<span class="c1">//           start = 719628L,</span>
<span class="c1">//           end = 719733L</span>
<span class="c1">//         )</span>
<span class="c1">//       )</span>
<span class="c1">//     ),</span>
<span class="c1">//     Round(</span>
<span class="c1">//       queries = List(</span>
<span class="c1">//         Request(</span>
<span class="c1">//           request = FetchOne(</span>
<span class="c1">//             id = 2,</span>
<span class="c1">//             data = repl.MdocSession$MdocApp$Users$@9a59a6e,</span>
<span class="c1">//             cached = true</span>
<span class="c1">//           ),</span>
<span class="c1">//           start = 719735L,</span>
<span class="c1">//           end = 719735L</span>
<span class="c1">//         )</span>
<span class="c1">//       )</span>
<span class="c1">//     ),</span>
<span class="c1">//     Round(</span>
<span class="c1">//       queries = List(</span>
<span class="c1">//         Request(</span>
<span class="c1">//           request = FetchOne(</span>
<span class="c1">//             id = 4,</span>
<span class="c1">//             data = repl.MdocSession$MdocApp$Users$@9a59a6e,</span>
<span class="c1">//             cached = false</span>
<span class="c1">//           ),</span>
<span class="c1">//           start = 719735L,</span>
<span class="c1">//           end = 719836L</span>
<span class="c1">//         )</span>
<span class="c1">//       )</span>
<span class="c1">//     ),</span>
<span class="c1">//     Round(</span>
<span class="c1">//       queries = List(</span>
<span class="c1">//         Request(</span>
<span class="c1">//           request = Batch(</span>
<span class="c1">//             ids = NonEmptyList(head = 1, tail = List(2, 3)),</span>
<span class="c1">//             data = repl.MdocSession$MdocApp$Posts$@4c6cf8c3,</span>
<span class="c1">//             cached = false</span>
<span class="c1">//           ),</span>
<span class="c1">// ...</span>
<span class="c1">// result4: String = "done"</span>

<span class="nv">io</span><span class="o">.</span><span class="py">unsafeRunTimed</span><span class="o">(</span><span class="mf">5.</span><span class="n">seconds</span><span class="o">)</span> <span class="k">match</span> <span class="o">{</span>
 <span class="k">case</span> <span class="nc">Some</span><span class="o">((</span><span class="n">log</span><span class="o">,</span> <span class="k">_</span><span class="o">))</span> <span class="k">=&gt;</span> <span class="nf">println</span><span class="o">(</span><span class="nf">describe</span><span class="o">(</span><span class="n">log</span><span class="o">))</span>
 <span class="k">case</span> <span class="nc">None</span> <span class="k">=&gt;</span> <span class="nf">println</span><span class="o">(</span><span class="s">"Unable to run fetch"</span><span class="o">)</span>
<span class="o">}</span>
<span class="c1">// Fetch execution 🕛 0.31 seconds</span>
<span class="c1">// </span>
<span class="c1">//   [Round 1] 🕛 0.10 seconds</span>
<span class="c1">//     [Batch] From `Users` with ids List(1, 2) cached false 🕛 0.10 seconds</span>
<span class="c1">//   [Round 2] 🕛 0.00 seconds</span>
<span class="c1">//     [Fetch one] From `Users` with id 2 cached true 🕛 0.00 seconds</span>
<span class="c1">//   [Round 3] 🕛 0.10 seconds</span>
<span class="c1">//     [Fetch one] From `Users` with id 4 cached false 🕛 0.10 seconds</span>
<span class="c1">//   [Round 4] 🕛 0.10 seconds</span>
<span class="c1">//     [Batch] From `Posts` with ids List(1, 2, 3) cached false 🕛 0.10 seconds</span>
<span class="c1">//     [Batch] From `Users` with ids List(3) cached false 🕛 0.10 seconds</span>
<span class="c1">//     [Batch] From `Users` with ids List(1, 2) cached true 🕛 0.00 seconds</span>
</code></pre></div></div>

<p>Let’s break down the output from <code class="highlighter-rouge">describe</code>:</p>

<ul>
  <li>The first line shows the total time that took to run the fetch</li>
  <li>The nested lines represent the different rounds of execution</li>
  <li>“Fetch one” rounds are executed for getting an identity from one data source</li>
  <li>“Batch” rounds are executed for getting a batch of identities from one data source</li>
</ul>

<h1 id="resources">Resources</h1>

<ul>
  <li><a href="https://github.com/47degrees/fetch">Code</a> on GitHub.</li>
  <li><a href="https://47degrees.github.io/fetch/">Documentation site</a></li>
  <li><a href="https://www.youtube.com/watch?v=45fcKYFb0EU">Fetch: Simple &amp; Efficient data access</a> talk at <a href="http://typelevel.org/event/2016-05-summit-oslo/">Typelevel Summit in Oslo</a></li>
</ul>

<h1 id="acknowledgements">Acknowledgements</h1>

<p>Fetch stands on the shoulders of giants:</p>

<ul>
  <li><a href="https://github.com/facebook/haxl">Haxl</a> is Facebook’s implementation (Haskell) of the <a href="http://community.haskell.org/~simonmar/papers/haxl-icfp14.pdf">original paper Fetch is based on</a>.</li>
  <li><a href="https://github.com/getclump/clump">Clump</a> has inspired the signature of the <code class="highlighter-rouge">DataSource#fetch*</code> methods.</li>
  <li><a href="https://engineering.twitter.com/university/videos/introducing-stitch">Stitch</a> is an in-house Twitter library that is not open source but has inspired Fetch’s high-level API.</li>
  <li><a href="http://typelevel.org/cats/">Cats</a>, a library for functional programming in Scala.</li>
  <li><a href="https://monix.io">Monix</a> high-performance and multiplatform (Scala / Scala.js) asynchronous programming library.</li>
</ul>
</section></div></div></div></div><script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/3.3.7/js/bootstrap.min.js"></script><script src="/fetch/highlight/highlight.pack.js"></script><script src="/fetch/lunr/lunr.js"></script><script>
// For all code blocks, copy the language from the containing div
// to the inner code tag (where hljs expects it to be)
const langPrefix = 'language-';
document.querySelectorAll(`div[class^='${langPrefix}']`).forEach(function(div) {
  div.classList.forEach(function(cssClass) {
    if (cssClass.startsWith(langPrefix)) {
      const lang = cssClass.substring(langPrefix.length);
      div.querySelectorAll('pre code').forEach(function(code) {
        code.classList.add(lang);
      });
    }
  });
});

hljs.configure({languages:['scala','java','bash']});
hljs.initHighlightingOnLoad();
      </script><script src="/fetch/js/automenu.js"></script><script>console.info('\x57\x65\x62\x73\x69\x74\x65\x20\x62\x75\x69\x6c\x74\x20\x77\x69\x74\x68\x3a\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x5f\x5f\x20\x20\x20\x20\x5f\x5f\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x5f\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x5f\x20\x5f\x5f\x0a\x20\x20\x20\x5f\x5f\x5f\x5f\x5f\x2f\x20\x2f\x5f\x20\x20\x2f\x20\x2f\x5f\x20\x20\x20\x20\x20\x20\x5f\x5f\x5f\x5f\x20\x5f\x5f\x5f\x20\x20\x28\x5f\x29\x5f\x5f\x5f\x5f\x5f\x5f\x5f\x5f\x5f\x5f\x5f\x5f\x5f\x20\x20\x5f\x5f\x5f\x5f\x5f\x28\x5f\x29\x20\x2f\x5f\x5f\x5f\x5f\x20\x20\x5f\x5f\x5f\x5f\x5f\x0a\x20\x20\x2f\x20\x5f\x5f\x5f\x2f\x20\x5f\x5f\x20\x5c\x2f\x20\x5f\x5f\x2f\x5f\x5f\x5f\x5f\x5f\x2f\x20\x5f\x5f\x20\x60\x5f\x5f\x20\x5c\x2f\x20\x2f\x20\x5f\x5f\x5f\x2f\x20\x5f\x5f\x5f\x2f\x20\x5f\x5f\x20\x5c\x2f\x20\x5f\x5f\x5f\x2f\x20\x2f\x20\x5f\x5f\x2f\x20\x5f\x20\x5c\x2f\x20\x5f\x5f\x5f\x2f\x0a\x20\x28\x5f\x5f\x20\x20\x29\x20\x2f\x5f\x2f\x20\x2f\x20\x2f\x5f\x2f\x5f\x5f\x5f\x5f\x5f\x2f\x20\x2f\x20\x2f\x20\x2f\x20\x2f\x20\x2f\x20\x2f\x20\x2f\x5f\x5f\x2f\x20\x2f\x20\x20\x2f\x20\x2f\x5f\x2f\x20\x28\x5f\x5f\x20\x20\x29\x20\x2f\x20\x2f\x5f\x2f\x20\x20\x5f\x5f\x28\x5f\x5f\x20\x20\x29\x0a\x2f\x5f\x5f\x5f\x5f\x2f\x5f\x2e\x5f\x5f\x5f\x2f\x5c\x5f\x5f\x2f\x20\x20\x20\x20\x20\x2f\x5f\x2f\x20\x2f\x5f\x2f\x20\x2f\x5f\x2f\x5f\x2f\x5c\x5f\x5f\x5f\x2f\x5f\x2f\x20\x20\x20\x5c\x5f\x5f\x5f\x5f\x2f\x5f\x5f\x5f\x5f\x2f\x5f\x2f\x5c\x5f\x5f\x2f\x5c\x5f\x5f\x5f\x2f\x5f\x5f\x5f\x5f\x2f\x0a\x0a\x68\x74\x74\x70\x73\x3a\x2f\x2f\x34\x37\x64\x65\x67\x2e\x67\x69\x74\x68\x75\x62\x2e\x69\x6f\x2f\x73\x62\x74\x2d\x6d\x69\x63\x72\x6f\x73\x69\x74\x65\x73')</script><script>((window.gitter = {}).chat = {}).options = {
room: '47degrees/fetch'};</script><script src="https://sidecar.gitter.im/dist/sidecar.v1.js"></script><script src="/fetch/js/search.js"></script><script src="/fetch/js/main.js"></script></body></html>